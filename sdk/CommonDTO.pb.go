// Code generated by protoc-gen-go.
// source: CommonDTO.proto
// DO NOT EDIT!

package sdk

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type EntityDTO_EntityType int32

const (
	EntityDTO_SWITCH                        EntityDTO_EntityType = 0
	EntityDTO_VIRTUAL_DATACENTER            EntityDTO_EntityType = 1
	EntityDTO_STORAGE                       EntityDTO_EntityType = 2
	EntityDTO_SERVICE                       EntityDTO_EntityType = 3
	EntityDTO_DATABASE                      EntityDTO_EntityType = 4
	EntityDTO_SAVINGS                       EntityDTO_EntityType = 5
	EntityDTO_OPERATOR                      EntityDTO_EntityType = 6
	EntityDTO_WEB_SERVER                    EntityDTO_EntityType = 7
	EntityDTO_RIGHT_SIZER                   EntityDTO_EntityType = 8
	EntityDTO_THREE_TIER_APPLICATION        EntityDTO_EntityType = 9
	EntityDTO_VIRTUAL_MACHINE               EntityDTO_EntityType = 10
	EntityDTO_DISK_ARRAY                    EntityDTO_EntityType = 11
	EntityDTO_DATACENTER                    EntityDTO_EntityType = 12
	EntityDTO_INFRASTRUCTURE                EntityDTO_EntityType = 13
	EntityDTO_PHYSICAL_MACHINE              EntityDTO_EntityType = 14
	EntityDTO_CHASSIS                       EntityDTO_EntityType = 15
	EntityDTO_LICENSING_SERVICE             EntityDTO_EntityType = 16
	EntityDTO_BUSINESS_USER                 EntityDTO_EntityType = 17
	EntityDTO_STORAGE_CONTROLLER            EntityDTO_EntityType = 18
	EntityDTO_HYPERVISOR                    EntityDTO_EntityType = 19
	EntityDTO_BUSINESS_ENTITY               EntityDTO_EntityType = 20
	EntityDTO_IO_MODULE                     EntityDTO_EntityType = 21
	EntityDTO_ACTION_MANAGER                EntityDTO_EntityType = 22
	EntityDTO_VLAN                          EntityDTO_EntityType = 23
	EntityDTO_APPLICATION_SERVER            EntityDTO_EntityType = 24
	EntityDTO_BUSINESS                      EntityDTO_EntityType = 25
	EntityDTO_VIRTUAL_APPLICATION           EntityDTO_EntityType = 26
	EntityDTO_NETWORKING_ENDPOINT           EntityDTO_EntityType = 27
	EntityDTO_BUSINESS_ACCOUNT              EntityDTO_EntityType = 28
	EntityDTO_IP                            EntityDTO_EntityType = 29
	EntityDTO_SERVICE_ENTITY_TEMPLATE       EntityDTO_EntityType = 30
	EntityDTO_PORT                          EntityDTO_EntityType = 31
	EntityDTO_NETWORK                       EntityDTO_EntityType = 32
	EntityDTO_APPLICATION                   EntityDTO_EntityType = 33
	EntityDTO_THIS_ENTITY                   EntityDTO_EntityType = 34
	EntityDTO_COMPUTE_RESOURCE              EntityDTO_EntityType = 35
	EntityDTO_MAC                           EntityDTO_EntityType = 36
	EntityDTO_INTERNET                      EntityDTO_EntityType = 37
	EntityDTO_MOVER                         EntityDTO_EntityType = 38
	EntityDTO_DISTRIBUTED_VIRTUAL_PORTGROUP EntityDTO_EntityType = 39
	EntityDTO_CONTAINER                     EntityDTO_EntityType = 40
	EntityDTO_CONTAINER_POD                 EntityDTO_EntityType = 41
	// 2047 is the largest tag value encoded in 2 bytes
	EntityDTO_UNKNOWN EntityDTO_EntityType = 2047
)

var EntityDTO_EntityType_name = map[int32]string{
	0:    "SWITCH",
	1:    "VIRTUAL_DATACENTER",
	2:    "STORAGE",
	3:    "SERVICE",
	4:    "DATABASE",
	5:    "SAVINGS",
	6:    "OPERATOR",
	7:    "WEB_SERVER",
	8:    "RIGHT_SIZER",
	9:    "THREE_TIER_APPLICATION",
	10:   "VIRTUAL_MACHINE",
	11:   "DISK_ARRAY",
	12:   "DATACENTER",
	13:   "INFRASTRUCTURE",
	14:   "PHYSICAL_MACHINE",
	15:   "CHASSIS",
	16:   "LICENSING_SERVICE",
	17:   "BUSINESS_USER",
	18:   "STORAGE_CONTROLLER",
	19:   "HYPERVISOR",
	20:   "BUSINESS_ENTITY",
	21:   "IO_MODULE",
	22:   "ACTION_MANAGER",
	23:   "VLAN",
	24:   "APPLICATION_SERVER",
	25:   "BUSINESS",
	26:   "VIRTUAL_APPLICATION",
	27:   "NETWORKING_ENDPOINT",
	28:   "BUSINESS_ACCOUNT",
	29:   "IP",
	30:   "SERVICE_ENTITY_TEMPLATE",
	31:   "PORT",
	32:   "NETWORK",
	33:   "APPLICATION",
	34:   "THIS_ENTITY",
	35:   "COMPUTE_RESOURCE",
	36:   "MAC",
	37:   "INTERNET",
	38:   "MOVER",
	39:   "DISTRIBUTED_VIRTUAL_PORTGROUP",
	40:   "CONTAINER",
	41:   "CONTAINER_POD",
	2047: "UNKNOWN",
}
var EntityDTO_EntityType_value = map[string]int32{
	"SWITCH":                 0,
	"VIRTUAL_DATACENTER":     1,
	"STORAGE":                2,
	"SERVICE":                3,
	"DATABASE":               4,
	"SAVINGS":                5,
	"OPERATOR":               6,
	"WEB_SERVER":             7,
	"RIGHT_SIZER":            8,
	"THREE_TIER_APPLICATION": 9,
	"VIRTUAL_MACHINE":        10,
	"DISK_ARRAY":             11,
	"DATACENTER":             12,
	"INFRASTRUCTURE":         13,
	"PHYSICAL_MACHINE":       14,
	"CHASSIS":                15,
	"LICENSING_SERVICE":      16,
	"BUSINESS_USER":          17,
	"STORAGE_CONTROLLER":     18,
	"HYPERVISOR":             19,
	"BUSINESS_ENTITY":        20,
	"IO_MODULE":              21,
	"ACTION_MANAGER":         22,
	"VLAN":                   23,
	"APPLICATION_SERVER":     24,
	"BUSINESS":               25,
	"VIRTUAL_APPLICATION":    26,
	"NETWORKING_ENDPOINT":    27,
	"BUSINESS_ACCOUNT":       28,
	"IP":                     29,
	"SERVICE_ENTITY_TEMPLATE": 30,
	"PORT":             31,
	"NETWORK":          32,
	"APPLICATION":      33,
	"THIS_ENTITY":      34,
	"COMPUTE_RESOURCE": 35,
	"MAC":              36,
	"INTERNET":         37,
	"MOVER":            38,
	"DISTRIBUTED_VIRTUAL_PORTGROUP": 39,
	"CONTAINER":                     40,
	"CONTAINER_POD":                 41,
	"UNKNOWN":                       2047,
}

func (x EntityDTO_EntityType) Enum() *EntityDTO_EntityType {
	p := new(EntityDTO_EntityType)
	*p = x
	return p
}
func (x EntityDTO_EntityType) String() string {
	return proto.EnumName(EntityDTO_EntityType_name, int32(x))
}
func (x *EntityDTO_EntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_EntityType_value, data, "EntityDTO_EntityType")
	if err != nil {
		return err
	}
	*x = EntityDTO_EntityType(value)
	return nil
}

// Enum for power state.
type EntityDTO_PowerState int32

const (
	EntityDTO_POWERED_ON         EntityDTO_PowerState = 1
	EntityDTO_POWERED_OFF        EntityDTO_PowerState = 2
	EntityDTO_SUSPENDED          EntityDTO_PowerState = 3
	EntityDTO_POWERSTATE_UNKNOWN EntityDTO_PowerState = 4
)

var EntityDTO_PowerState_name = map[int32]string{
	1: "POWERED_ON",
	2: "POWERED_OFF",
	3: "SUSPENDED",
	4: "POWERSTATE_UNKNOWN",
}
var EntityDTO_PowerState_value = map[string]int32{
	"POWERED_ON":         1,
	"POWERED_OFF":        2,
	"SUSPENDED":          3,
	"POWERSTATE_UNKNOWN": 4,
}

func (x EntityDTO_PowerState) Enum() *EntityDTO_PowerState {
	p := new(EntityDTO_PowerState)
	*p = x
	return p
}
func (x EntityDTO_PowerState) String() string {
	return proto.EnumName(EntityDTO_PowerState_name, int32(x))
}
func (x *EntityDTO_PowerState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_PowerState_value, data, "EntityDTO_PowerState")
	if err != nil {
		return err
	}
	*x = EntityDTO_PowerState(value)
	return nil
}

// A virtual datacenter may be either a consumer or producer
type EntityDTO_VirtualDatacenterRole int32

const (
	EntityDTO_CONSUMER EntityDTO_VirtualDatacenterRole = 1
	EntityDTO_PRODUCER EntityDTO_VirtualDatacenterRole = 2
)

var EntityDTO_VirtualDatacenterRole_name = map[int32]string{
	1: "CONSUMER",
	2: "PRODUCER",
}
var EntityDTO_VirtualDatacenterRole_value = map[string]int32{
	"CONSUMER": 1,
	"PRODUCER": 2,
}

func (x EntityDTO_VirtualDatacenterRole) Enum() *EntityDTO_VirtualDatacenterRole {
	p := new(EntityDTO_VirtualDatacenterRole)
	*p = x
	return p
}
func (x EntityDTO_VirtualDatacenterRole) String() string {
	return proto.EnumName(EntityDTO_VirtualDatacenterRole_name, int32(x))
}
func (x *EntityDTO_VirtualDatacenterRole) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_VirtualDatacenterRole_value, data, "EntityDTO_VirtualDatacenterRole")
	if err != nil {
		return err
	}
	*x = EntityDTO_VirtualDatacenterRole(value)
	return nil
}

// Names for communicating the number of various types of disks.
type EntityDTO_NumDiskNames int32

const (
	// Number of discovered solid state drives.
	EntityDTO_NUM_SSD EntityDTO_NumDiskNames = 1
	// Number of discovered 7200 RPM disks.
	EntityDTO_NUM_7200_DISKS EntityDTO_NumDiskNames = 2
	// Number of discovered 10000 RPM disks.
	EntityDTO_NUM_10K_DISKS EntityDTO_NumDiskNames = 3
	// Number of discovered 15000 RPM disks.
	EntityDTO_NUM_15K_DISKS EntityDTO_NumDiskNames = 4
	// Number of discovered VSeries disks.
	EntityDTO_NUM_VSERIES_DISKS EntityDTO_NumDiskNames = 5
)

var EntityDTO_NumDiskNames_name = map[int32]string{
	1: "NUM_SSD",
	2: "NUM_7200_DISKS",
	3: "NUM_10K_DISKS",
	4: "NUM_15K_DISKS",
	5: "NUM_VSERIES_DISKS",
}
var EntityDTO_NumDiskNames_value = map[string]int32{
	"NUM_SSD":           1,
	"NUM_7200_DISKS":    2,
	"NUM_10K_DISKS":     3,
	"NUM_15K_DISKS":     4,
	"NUM_VSERIES_DISKS": 5,
}

func (x EntityDTO_NumDiskNames) Enum() *EntityDTO_NumDiskNames {
	p := new(EntityDTO_NumDiskNames)
	*p = x
	return p
}
func (x EntityDTO_NumDiskNames) String() string {
	return proto.EnumName(EntityDTO_NumDiskNames_name, int32(x))
}
func (x *EntityDTO_NumDiskNames) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_NumDiskNames_value, data, "EntityDTO_NumDiskNames")
	if err != nil {
		return err
	}
	*x = EntityDTO_NumDiskNames(value)
	return nil
}

// Specifies the origin of an entity, either DISCOVERED or PROXY
// DISCOVERED: An entity discovered by the probe that maps to a real resource found
// when probing the target.
// PROXY: An entity supplied by the probe to fill out a required part of the supply chain.
// For example, a probe discovering Virtual Machines may supply a Guestload Application proxy
// to complete its supply chain.
// Some proxy entities may be replaced by discovered entities found by another probe."
type EntityDTO_EntityOrigin int32

const (
	EntityDTO_DISCOVERED EntityDTO_EntityOrigin = 1
	EntityDTO_PROXY      EntityDTO_EntityOrigin = 2
)

var EntityDTO_EntityOrigin_name = map[int32]string{
	1: "DISCOVERED",
	2: "PROXY",
}
var EntityDTO_EntityOrigin_value = map[string]int32{
	"DISCOVERED": 1,
	"PROXY":      2,
}

func (x EntityDTO_EntityOrigin) Enum() *EntityDTO_EntityOrigin {
	p := new(EntityDTO_EntityOrigin)
	*p = x
	return p
}
func (x EntityDTO_EntityOrigin) String() string {
	return proto.EnumName(EntityDTO_EntityOrigin_name, int32(x))
}
func (x *EntityDTO_EntityOrigin) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntityDTO_EntityOrigin_value, data, "EntityDTO_EntityOrigin")
	if err != nil {
		return err
	}
	*x = EntityDTO_EntityOrigin(value)
	return nil
}

type CommodityDTO_CommodityType int32

const (
	CommodityDTO_CLUSTER                    CommodityDTO_CommodityType = 0
	CommodityDTO_THREADS                    CommodityDTO_CommodityType = 1
	CommodityDTO_CPU_ALLOCATION             CommodityDTO_CommodityType = 2
	CommodityDTO_NUMBER_CONSUMERS           CommodityDTO_CommodityType = 3
	CommodityDTO_FLOW_ALLOCATION            CommodityDTO_CommodityType = 4
	CommodityDTO_Q1_VCPU                    CommodityDTO_CommodityType = 5
	CommodityDTO_STORAGE_PROVISIONED        CommodityDTO_CommodityType = 6
	CommodityDTO_LICENSE_COMMODITY          CommodityDTO_CommodityType = 7
	CommodityDTO_STORAGE_AMOUNT             CommodityDTO_CommodityType = 8
	CommodityDTO_Q16_VCPU                   CommodityDTO_CommodityType = 9
	CommodityDTO_Q32_VCPU                   CommodityDTO_CommodityType = 10
	CommodityDTO_SAME_CLUSTER_MOVE_SVC      CommodityDTO_CommodityType = 11
	CommodityDTO_Q3_VCPU                    CommodityDTO_CommodityType = 12
	CommodityDTO_SLA_COMMODITY              CommodityDTO_CommodityType = 13
	CommodityDTO_CROSS_CLUSTER_MOVE_SVC     CommodityDTO_CommodityType = 14
	CommodityDTO_NUMBER_CONSUMERS_PM        CommodityDTO_CommodityType = 15
	CommodityDTO_STORAGE_ALLOCATION         CommodityDTO_CommodityType = 16
	CommodityDTO_Q8_VCPU                    CommodityDTO_CommodityType = 17
	CommodityDTO_SPACE                      CommodityDTO_CommodityType = 18
	CommodityDTO_Q6_VCPU                    CommodityDTO_CommodityType = 19
	CommodityDTO_POWER                      CommodityDTO_CommodityType = 20
	CommodityDTO_MEM                        CommodityDTO_CommodityType = 21
	CommodityDTO_STORAGE_LATENCY            CommodityDTO_CommodityType = 22
	CommodityDTO_Q7_VCPU                    CommodityDTO_CommodityType = 23
	CommodityDTO_COOLING                    CommodityDTO_CommodityType = 24
	CommodityDTO_PORT_CHANEL                CommodityDTO_CommodityType = 25
	CommodityDTO_VCPU                       CommodityDTO_CommodityType = 26
	CommodityDTO_QN_VCPU                    CommodityDTO_CommodityType = 27
	CommodityDTO_CPU_PROVISIONED            CommodityDTO_CommodityType = 28
	CommodityDTO_RIGHT_SIZE_SVC             CommodityDTO_CommodityType = 29
	CommodityDTO_MOVE                       CommodityDTO_CommodityType = 30
	CommodityDTO_Q2_VCPU                    CommodityDTO_CommodityType = 31
	CommodityDTO_Q5_VCPU                    CommodityDTO_CommodityType = 32
	CommodityDTO_SWAPPING                   CommodityDTO_CommodityType = 33
	CommodityDTO_SEGMENTATION               CommodityDTO_CommodityType = 34
	CommodityDTO_FLOW                       CommodityDTO_CommodityType = 35
	CommodityDTO_DATASTORE                  CommodityDTO_CommodityType = 36
	CommodityDTO_CROSS_CLOUD_MOVE_SVC       CommodityDTO_CommodityType = 37
	CommodityDTO_RIGHT_SIZE_DOWN            CommodityDTO_CommodityType = 38
	CommodityDTO_IO_THROUGHPUT              CommodityDTO_CommodityType = 39
	CommodityDTO_CPU                        CommodityDTO_CommodityType = 40
	CommodityDTO_BALLOONING                 CommodityDTO_CommodityType = 41
	CommodityDTO_VDC                        CommodityDTO_CommodityType = 42
	CommodityDTO_Q64_VCPU                   CommodityDTO_CommodityType = 43
	CommodityDTO_CONNECTION                 CommodityDTO_CommodityType = 44
	CommodityDTO_MEM_PROVISIONED            CommodityDTO_CommodityType = 45
	CommodityDTO_STORAGE                    CommodityDTO_CommodityType = 46
	CommodityDTO_NET_THROUGHPUT             CommodityDTO_CommodityType = 47
	CommodityDTO_NUMBER_CONSUMERS_STORAGE   CommodityDTO_CommodityType = 48
	CommodityDTO_TRANSACTION                CommodityDTO_CommodityType = 49
	CommodityDTO_MEM_ALLOCATION             CommodityDTO_CommodityType = 50
	CommodityDTO_DSPM_ACCESS                CommodityDTO_CommodityType = 51
	CommodityDTO_RESPONSE_TIME              CommodityDTO_CommodityType = 52
	CommodityDTO_VMEM                       CommodityDTO_CommodityType = 53
	CommodityDTO_ACTION_PERMIT              CommodityDTO_CommodityType = 54
	CommodityDTO_DATACENTER                 CommodityDTO_CommodityType = 55
	CommodityDTO_APPLICATION                CommodityDTO_CommodityType = 56
	CommodityDTO_NETWORK                    CommodityDTO_CommodityType = 57
	CommodityDTO_Q4_VCPU                    CommodityDTO_CommodityType = 58
	CommodityDTO_STORAGE_CLUSTER            CommodityDTO_CommodityType = 59
	CommodityDTO_EXTENT                     CommodityDTO_CommodityType = 60
	CommodityDTO_ACCESS                     CommodityDTO_CommodityType = 61
	CommodityDTO_RIGHT_SIZE_UP              CommodityDTO_CommodityType = 62
	CommodityDTO_VAPP_ACCESS                CommodityDTO_CommodityType = 63
	CommodityDTO_STORAGE_ACCESS             CommodityDTO_CommodityType = 64
	CommodityDTO_VSTORAGE                   CommodityDTO_CommodityType = 65
	CommodityDTO_DRS_SEGMENTATION           CommodityDTO_CommodityType = 66
	CommodityDTO_DB_MEM                     CommodityDTO_CommodityType = 67
	CommodityDTO_TRANSACTION_LOG            CommodityDTO_CommodityType = 68
	CommodityDTO_DB_CACHE_HIT_RATE          CommodityDTO_CommodityType = 69
	CommodityDTO_HOT_STORAGE                CommodityDTO_CommodityType = 70
	CommodityDTO_COLLECTION_TIME            CommodityDTO_CommodityType = 71
	CommodityDTO_BUFFER_COMMODITY           CommodityDTO_CommodityType = 72
	CommodityDTO_SOFTWARE_LICENSE_COMMODITY CommodityDTO_CommodityType = 73
	CommodityDTO_VMPM_ACCESS                CommodityDTO_CommodityType = 74
	// 2047 is the largest tag value encoded in 2 bytes
	CommodityDTO_UNKNOWN CommodityDTO_CommodityType = 2047
)

var CommodityDTO_CommodityType_name = map[int32]string{
	0:    "CLUSTER",
	1:    "THREADS",
	2:    "CPU_ALLOCATION",
	3:    "NUMBER_CONSUMERS",
	4:    "FLOW_ALLOCATION",
	5:    "Q1_VCPU",
	6:    "STORAGE_PROVISIONED",
	7:    "LICENSE_COMMODITY",
	8:    "STORAGE_AMOUNT",
	9:    "Q16_VCPU",
	10:   "Q32_VCPU",
	11:   "SAME_CLUSTER_MOVE_SVC",
	12:   "Q3_VCPU",
	13:   "SLA_COMMODITY",
	14:   "CROSS_CLUSTER_MOVE_SVC",
	15:   "NUMBER_CONSUMERS_PM",
	16:   "STORAGE_ALLOCATION",
	17:   "Q8_VCPU",
	18:   "SPACE",
	19:   "Q6_VCPU",
	20:   "POWER",
	21:   "MEM",
	22:   "STORAGE_LATENCY",
	23:   "Q7_VCPU",
	24:   "COOLING",
	25:   "PORT_CHANEL",
	26:   "VCPU",
	27:   "QN_VCPU",
	28:   "CPU_PROVISIONED",
	29:   "RIGHT_SIZE_SVC",
	30:   "MOVE",
	31:   "Q2_VCPU",
	32:   "Q5_VCPU",
	33:   "SWAPPING",
	34:   "SEGMENTATION",
	35:   "FLOW",
	36:   "DATASTORE",
	37:   "CROSS_CLOUD_MOVE_SVC",
	38:   "RIGHT_SIZE_DOWN",
	39:   "IO_THROUGHPUT",
	40:   "CPU",
	41:   "BALLOONING",
	42:   "VDC",
	43:   "Q64_VCPU",
	44:   "CONNECTION",
	45:   "MEM_PROVISIONED",
	46:   "STORAGE",
	47:   "NET_THROUGHPUT",
	48:   "NUMBER_CONSUMERS_STORAGE",
	49:   "TRANSACTION",
	50:   "MEM_ALLOCATION",
	51:   "DSPM_ACCESS",
	52:   "RESPONSE_TIME",
	53:   "VMEM",
	54:   "ACTION_PERMIT",
	55:   "DATACENTER",
	56:   "APPLICATION",
	57:   "NETWORK",
	58:   "Q4_VCPU",
	59:   "STORAGE_CLUSTER",
	60:   "EXTENT",
	61:   "ACCESS",
	62:   "RIGHT_SIZE_UP",
	63:   "VAPP_ACCESS",
	64:   "STORAGE_ACCESS",
	65:   "VSTORAGE",
	66:   "DRS_SEGMENTATION",
	67:   "DB_MEM",
	68:   "TRANSACTION_LOG",
	69:   "DB_CACHE_HIT_RATE",
	70:   "HOT_STORAGE",
	71:   "COLLECTION_TIME",
	72:   "BUFFER_COMMODITY",
	73:   "SOFTWARE_LICENSE_COMMODITY",
	74:   "VMPM_ACCESS",
	2047: "UNKNOWN",
}
var CommodityDTO_CommodityType_value = map[string]int32{
	"CLUSTER":                    0,
	"THREADS":                    1,
	"CPU_ALLOCATION":             2,
	"NUMBER_CONSUMERS":           3,
	"FLOW_ALLOCATION":            4,
	"Q1_VCPU":                    5,
	"STORAGE_PROVISIONED":        6,
	"LICENSE_COMMODITY":          7,
	"STORAGE_AMOUNT":             8,
	"Q16_VCPU":                   9,
	"Q32_VCPU":                   10,
	"SAME_CLUSTER_MOVE_SVC":      11,
	"Q3_VCPU":                    12,
	"SLA_COMMODITY":              13,
	"CROSS_CLUSTER_MOVE_SVC":     14,
	"NUMBER_CONSUMERS_PM":        15,
	"STORAGE_ALLOCATION":         16,
	"Q8_VCPU":                    17,
	"SPACE":                      18,
	"Q6_VCPU":                    19,
	"POWER":                      20,
	"MEM":                        21,
	"STORAGE_LATENCY":            22,
	"Q7_VCPU":                    23,
	"COOLING":                    24,
	"PORT_CHANEL":                25,
	"VCPU":                       26,
	"QN_VCPU":                    27,
	"CPU_PROVISIONED":            28,
	"RIGHT_SIZE_SVC":             29,
	"MOVE":                       30,
	"Q2_VCPU":                    31,
	"Q5_VCPU":                    32,
	"SWAPPING":                   33,
	"SEGMENTATION":               34,
	"FLOW":                       35,
	"DATASTORE":                  36,
	"CROSS_CLOUD_MOVE_SVC":       37,
	"RIGHT_SIZE_DOWN":            38,
	"IO_THROUGHPUT":              39,
	"CPU":                        40,
	"BALLOONING":                 41,
	"VDC":                        42,
	"Q64_VCPU":                   43,
	"CONNECTION":                 44,
	"MEM_PROVISIONED":            45,
	"STORAGE":                    46,
	"NET_THROUGHPUT":             47,
	"NUMBER_CONSUMERS_STORAGE":   48,
	"TRANSACTION":                49,
	"MEM_ALLOCATION":             50,
	"DSPM_ACCESS":                51,
	"RESPONSE_TIME":              52,
	"VMEM":                       53,
	"ACTION_PERMIT":              54,
	"DATACENTER":                 55,
	"APPLICATION":                56,
	"NETWORK":                    57,
	"Q4_VCPU":                    58,
	"STORAGE_CLUSTER":            59,
	"EXTENT":                     60,
	"ACCESS":                     61,
	"RIGHT_SIZE_UP":              62,
	"VAPP_ACCESS":                63,
	"STORAGE_ACCESS":             64,
	"VSTORAGE":                   65,
	"DRS_SEGMENTATION":           66,
	"DB_MEM":                     67,
	"TRANSACTION_LOG":            68,
	"DB_CACHE_HIT_RATE":          69,
	"HOT_STORAGE":                70,
	"COLLECTION_TIME":            71,
	"BUFFER_COMMODITY":           72,
	"SOFTWARE_LICENSE_COMMODITY": 73,
	"VMPM_ACCESS":                74,
	"UNKNOWN":                    2047,
}

func (x CommodityDTO_CommodityType) Enum() *CommodityDTO_CommodityType {
	p := new(CommodityDTO_CommodityType)
	*p = x
	return p
}
func (x CommodityDTO_CommodityType) String() string {
	return proto.EnumName(CommodityDTO_CommodityType_name, int32(x))
}
func (x *CommodityDTO_CommodityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommodityDTO_CommodityType_value, data, "CommodityDTO_CommodityType")
	if err != nil {
		return err
	}
	*x = CommodityDTO_CommodityType(value)
	return nil
}

// Enum type notifying constraint's type
type GroupDTO_ConstraintType int32

const (
	GroupDTO_BUYER_SELLER_AFFINITY      GroupDTO_ConstraintType = 0
	GroupDTO_BUYER_SELLER_ANTI_AFFINITY GroupDTO_ConstraintType = 1
	GroupDTO_BUYER_BUYER_AFFINITY       GroupDTO_ConstraintType = 2
	GroupDTO_BUYER_BUYER_ANTI_AFFINITY  GroupDTO_ConstraintType = 3
	GroupDTO_CLUSTER                    GroupDTO_ConstraintType = 4
	GroupDTO_MERGE                      GroupDTO_ConstraintType = 5
)

var GroupDTO_ConstraintType_name = map[int32]string{
	0: "BUYER_SELLER_AFFINITY",
	1: "BUYER_SELLER_ANTI_AFFINITY",
	2: "BUYER_BUYER_AFFINITY",
	3: "BUYER_BUYER_ANTI_AFFINITY",
	4: "CLUSTER",
	5: "MERGE",
}
var GroupDTO_ConstraintType_value = map[string]int32{
	"BUYER_SELLER_AFFINITY":      0,
	"BUYER_SELLER_ANTI_AFFINITY": 1,
	"BUYER_BUYER_AFFINITY":       2,
	"BUYER_BUYER_ANTI_AFFINITY":  3,
	"CLUSTER":                    4,
	"MERGE":                      5,
}

func (x GroupDTO_ConstraintType) Enum() *GroupDTO_ConstraintType {
	p := new(GroupDTO_ConstraintType)
	*p = x
	return p
}
func (x GroupDTO_ConstraintType) String() string {
	return proto.EnumName(GroupDTO_ConstraintType_name, int32(x))
}
func (x *GroupDTO_ConstraintType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupDTO_ConstraintType_value, data, "GroupDTO_ConstraintType")
	if err != nil {
		return err
	}
	*x = GroupDTO_ConstraintType(value)
	return nil
}

// Enum notifying expression type used to match entities' property value
// with target value in SelectionSpec
type GroupDTO_SelectionSpec_ExpressionType int32

const (
	GroupDTO_SelectionSpec_EQUAL_TO                 GroupDTO_SelectionSpec_ExpressionType = 0
	GroupDTO_SelectionSpec_NOT_EQUAL_TO             GroupDTO_SelectionSpec_ExpressionType = 1
	GroupDTO_SelectionSpec_LARGER_THAN              GroupDTO_SelectionSpec_ExpressionType = 2
	GroupDTO_SelectionSpec_LARGER_THAN_OR_EQUAL_TO  GroupDTO_SelectionSpec_ExpressionType = 3
	GroupDTO_SelectionSpec_SMALLER_THAN             GroupDTO_SelectionSpec_ExpressionType = 4
	GroupDTO_SelectionSpec_SMALLER_THAN_OR_EQUAL_TO GroupDTO_SelectionSpec_ExpressionType = 5
	GroupDTO_SelectionSpec_CONTAINS                 GroupDTO_SelectionSpec_ExpressionType = 6
	GroupDTO_SelectionSpec_NOT_CONTAINS             GroupDTO_SelectionSpec_ExpressionType = 7
	GroupDTO_SelectionSpec_CONTAINED_BY             GroupDTO_SelectionSpec_ExpressionType = 8
	GroupDTO_SelectionSpec_NOT_CONTAINED_BY         GroupDTO_SelectionSpec_ExpressionType = 9
	GroupDTO_SelectionSpec_REGEX                    GroupDTO_SelectionSpec_ExpressionType = 10
	GroupDTO_SelectionSpec_LIST_OVERLAP             GroupDTO_SelectionSpec_ExpressionType = 11
	GroupDTO_SelectionSpec_LIST_NOT_OVERLAP         GroupDTO_SelectionSpec_ExpressionType = 12
	GroupDTO_SelectionSpec_LIST_FULL_CONTAINS       GroupDTO_SelectionSpec_ExpressionType = 13
	GroupDTO_SelectionSpec_LIST_FULL_CONTAINED_BY   GroupDTO_SelectionSpec_ExpressionType = 14
)

var GroupDTO_SelectionSpec_ExpressionType_name = map[int32]string{
	0:  "EQUAL_TO",
	1:  "NOT_EQUAL_TO",
	2:  "LARGER_THAN",
	3:  "LARGER_THAN_OR_EQUAL_TO",
	4:  "SMALLER_THAN",
	5:  "SMALLER_THAN_OR_EQUAL_TO",
	6:  "CONTAINS",
	7:  "NOT_CONTAINS",
	8:  "CONTAINED_BY",
	9:  "NOT_CONTAINED_BY",
	10: "REGEX",
	11: "LIST_OVERLAP",
	12: "LIST_NOT_OVERLAP",
	13: "LIST_FULL_CONTAINS",
	14: "LIST_FULL_CONTAINED_BY",
}
var GroupDTO_SelectionSpec_ExpressionType_value = map[string]int32{
	"EQUAL_TO":                 0,
	"NOT_EQUAL_TO":             1,
	"LARGER_THAN":              2,
	"LARGER_THAN_OR_EQUAL_TO":  3,
	"SMALLER_THAN":             4,
	"SMALLER_THAN_OR_EQUAL_TO": 5,
	"CONTAINS":                 6,
	"NOT_CONTAINS":             7,
	"CONTAINED_BY":             8,
	"NOT_CONTAINED_BY":         9,
	"REGEX":                    10,
	"LIST_OVERLAP":             11,
	"LIST_NOT_OVERLAP":         12,
	"LIST_FULL_CONTAINS":       13,
	"LIST_FULL_CONTAINED_BY":   14,
}

func (x GroupDTO_SelectionSpec_ExpressionType) Enum() *GroupDTO_SelectionSpec_ExpressionType {
	p := new(GroupDTO_SelectionSpec_ExpressionType)
	*p = x
	return p
}
func (x GroupDTO_SelectionSpec_ExpressionType) String() string {
	return proto.EnumName(GroupDTO_SelectionSpec_ExpressionType_name, int32(x))
}
func (x *GroupDTO_SelectionSpec_ExpressionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GroupDTO_SelectionSpec_ExpressionType_value, data, "GroupDTO_SelectionSpec_ExpressionType")
	if err != nil {
		return err
	}
	*x = GroupDTO_SelectionSpec_ExpressionType(value)
	return nil
}

//
// The EntityDTO message represents an Entity discovered in the target that your probe is
// monitoring
//
// Each entity must have a unique ID to identify it in the Operations Manager market.
// Many targets provide unique IDs for their entities, or you can generate your own.
// To guarantee that it's unique, you can give the ID a prefix that identifies your
// probe and the given target.
//
// Specify entity type by setting an 'EntityType' value to the 'entity' field.
//
// The 'displayName' value appears in the product GUI and in reports to identify the entity.
//
// An entity can maintain a list of commodities that it sells (see 'CommodityDTO').
//
// An entity can maintain a map of commodities bought (see {@code CommodityDTO}). Each map key is the unique ID of the
// provider entity. For each provider, the map entry is a list of the commodities bought from that provider.
//
// The entity's list of properties stores metadata about the entity - for example, you would store
// the entity's IP address as a property. To stitch this entity into the Operations Manager topology,
// you will create an ExternalEntityLink. That link includes the properties
// that Operations Manager can use to match the discovered entity and stitch it in.
//
type EntityDTO struct {
	EntityType  *EntityDTO_EntityType `protobuf:"varint,1,req,name=entityType,enum=common_dto.EntityDTO_EntityType" json:"entityType,omitempty"`
	Id          *string               `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	DisplayName *string               `protobuf:"bytes,3,opt,name=displayName" json:"displayName,omitempty"`
	// The {@link CommodityDTO} items this entity sells to its consumers.
	// This is a map of sold commodities where
	CommoditiesSold []*CommodityDTO `protobuf:"bytes,4,rep,name=commoditiesSold" json:"commoditiesSold,omitempty"`
	// The {@link CommodityDTO} items this entity buys from the different providers.
	// This is a map of bought commodities where:<ul>
	CommoditiesBought []*EntityDTO_CommodityBought `protobuf:"bytes,5,rep,name=commoditiesBought" json:"commoditiesBought,omitempty"`
	// List of the IDs of the entities that this entity is underlying. For example, an IO Module can underly
	// physical machines, or a physical machine can underly datastores.
	Underlying []string `protobuf:"bytes,6,rep,name=underlying" json:"underlying,omitempty"`
	// Entity properties in free (string <-> string) form, used for user-defined values.
	EntityProperties []*EntityDTO_EntityProperty `protobuf:"bytes,7,rep,name=entityProperties" json:"entityProperties,omitempty"`
	// Specifies the source of the entity (ie DISCOVERED or PROXY).
	// For further details see the comments for EntityOrigin.
	Origin *EntityDTO_EntityOrigin `protobuf:"varint,8,opt,name=origin,enum=common_dto.EntityDTO_EntityOrigin,def=1" json:"origin,omitempty"`
	// Proxy entities may be replaced by entities discovered by another probe.
	// Some proxy entities are aware of the entity replacing them based on a set of property values.
	// Before replacing they may also transfer the commodity data to the server entity
	ReplacementEntityData *EntityDTO_ReplacementEntityMetaData `protobuf:"bytes,9,opt,name=replacementEntityData" json:"replacementEntityData,omitempty"`
	// Specifies if the entity is monitored or not.
	// If this field is false, state of the entity will be set to NOT_MONITORED in server.
	// NOT_MONITORED state will imply that the entity is not participating in the Market Analysis.
	Monitored *bool `protobuf:"varint,10,opt,name=monitored,def=1" json:"monitored,omitempty"`
	// Specifies the power state of the entity.
	PowerState *EntityDTO_PowerState `protobuf:"varint,11,opt,name=powerState,enum=common_dto.EntityDTO_PowerState,def=1" json:"powerState,omitempty"`
	// Specified properties required for the behavior of the entity as a consumer.
	ConsumerPolicy *EntityDTO_ConsumerPolicy `protobuf:"bytes,12,opt,name=consumerPolicy" json:"consumerPolicy,omitempty"`
	// Specified properties required for the behavior of the entity as a provider.
	ProviderPolicy               *EntityDTO_ProviderPolicy               `protobuf:"bytes,13,opt,name=providerPolicy" json:"providerPolicy,omitempty"`
	StorageData                  *EntityDTO_StorageData                  `protobuf:"bytes,500,opt,name=storage_data" json:"storage_data,omitempty"`
	DiskArrayData                *EntityDTO_DiskArrayData                `protobuf:"bytes,501,opt,name=disk_array_data" json:"disk_array_data,omitempty"`
	ApplicationData              *EntityDTO_ApplicationData              `protobuf:"bytes,502,opt,name=application_data" json:"application_data,omitempty"`
	VirtualMachineData           *EntityDTO_VirtualMachineData           `protobuf:"bytes,503,opt,name=virtual_machine_data" json:"virtual_machine_data,omitempty"`
	PhysicalMachineData          *EntityDTO_PhysicalMachineData          `protobuf:"bytes,504,opt,name=physical_machine_data" json:"physical_machine_data,omitempty"`
	VirtualDatacenterData        *EntityDTO_VirtualDatacenterData        `protobuf:"bytes,505,opt,name=virtual_datacenter_data" json:"virtual_datacenter_data,omitempty"`
	VirtualMachineRelatedData    *EntityDTO_VirtualMachineRelatedData    `protobuf:"bytes,1000,opt,name=virtual_machine_related_data" json:"virtual_machine_related_data,omitempty"`
	PhysicalMachineRelatedData   *EntityDTO_PhysicalMachineRelatedData   `protobuf:"bytes,1001,opt,name=physical_machine_related_data" json:"physical_machine_related_data,omitempty"`
	StorageControllerRelatedData *EntityDTO_StorageControllerRelatedData `protobuf:"bytes,1002,opt,name=storage_controller_related_data" json:"storage_controller_related_data,omitempty"`
	XXX_unrecognized             []byte                                  `json:"-"`
}

func (m *EntityDTO) Reset()         { *m = EntityDTO{} }
func (m *EntityDTO) String() string { return proto.CompactTextString(m) }
func (*EntityDTO) ProtoMessage()    {}

const Default_EntityDTO_Origin EntityDTO_EntityOrigin = EntityDTO_DISCOVERED
const Default_EntityDTO_Monitored bool = true
const Default_EntityDTO_PowerState EntityDTO_PowerState = EntityDTO_POWERED_ON

func (m *EntityDTO) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *EntityDTO) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO) GetCommoditiesSold() []*CommodityDTO {
	if m != nil {
		return m.CommoditiesSold
	}
	return nil
}

func (m *EntityDTO) GetCommoditiesBought() []*EntityDTO_CommodityBought {
	if m != nil {
		return m.CommoditiesBought
	}
	return nil
}

func (m *EntityDTO) GetUnderlying() []string {
	if m != nil {
		return m.Underlying
	}
	return nil
}

func (m *EntityDTO) GetEntityProperties() []*EntityDTO_EntityProperty {
	if m != nil {
		return m.EntityProperties
	}
	return nil
}

func (m *EntityDTO) GetOrigin() EntityDTO_EntityOrigin {
	if m != nil && m.Origin != nil {
		return *m.Origin
	}
	return Default_EntityDTO_Origin
}

func (m *EntityDTO) GetReplacementEntityData() *EntityDTO_ReplacementEntityMetaData {
	if m != nil {
		return m.ReplacementEntityData
	}
	return nil
}

func (m *EntityDTO) GetMonitored() bool {
	if m != nil && m.Monitored != nil {
		return *m.Monitored
	}
	return Default_EntityDTO_Monitored
}

func (m *EntityDTO) GetPowerState() EntityDTO_PowerState {
	if m != nil && m.PowerState != nil {
		return *m.PowerState
	}
	return Default_EntityDTO_PowerState
}

func (m *EntityDTO) GetConsumerPolicy() *EntityDTO_ConsumerPolicy {
	if m != nil {
		return m.ConsumerPolicy
	}
	return nil
}

func (m *EntityDTO) GetProviderPolicy() *EntityDTO_ProviderPolicy {
	if m != nil {
		return m.ProviderPolicy
	}
	return nil
}

func (m *EntityDTO) GetStorageData() *EntityDTO_StorageData {
	if m != nil {
		return m.StorageData
	}
	return nil
}

func (m *EntityDTO) GetDiskArrayData() *EntityDTO_DiskArrayData {
	if m != nil {
		return m.DiskArrayData
	}
	return nil
}

func (m *EntityDTO) GetApplicationData() *EntityDTO_ApplicationData {
	if m != nil {
		return m.ApplicationData
	}
	return nil
}

func (m *EntityDTO) GetVirtualMachineData() *EntityDTO_VirtualMachineData {
	if m != nil {
		return m.VirtualMachineData
	}
	return nil
}

func (m *EntityDTO) GetPhysicalMachineData() *EntityDTO_PhysicalMachineData {
	if m != nil {
		return m.PhysicalMachineData
	}
	return nil
}

func (m *EntityDTO) GetVirtualDatacenterData() *EntityDTO_VirtualDatacenterData {
	if m != nil {
		return m.VirtualDatacenterData
	}
	return nil
}

func (m *EntityDTO) GetVirtualMachineRelatedData() *EntityDTO_VirtualMachineRelatedData {
	if m != nil {
		return m.VirtualMachineRelatedData
	}
	return nil
}

func (m *EntityDTO) GetPhysicalMachineRelatedData() *EntityDTO_PhysicalMachineRelatedData {
	if m != nil {
		return m.PhysicalMachineRelatedData
	}
	return nil
}

func (m *EntityDTO) GetStorageControllerRelatedData() *EntityDTO_StorageControllerRelatedData {
	if m != nil {
		return m.StorageControllerRelatedData
	}
	return nil
}

type EntityDTO_CommodityBought struct {
	// ID of the provider entity
	ProviderId *string `protobuf:"bytes,1,req,name=providerId" json:"providerId,omitempty"`
	// list of CommodityDTO items bought from the provider entity
	Bought           []*CommodityDTO `protobuf:"bytes,2,rep,name=bought" json:"bought,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *EntityDTO_CommodityBought) Reset()         { *m = EntityDTO_CommodityBought{} }
func (m *EntityDTO_CommodityBought) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_CommodityBought) ProtoMessage()    {}

func (m *EntityDTO_CommodityBought) GetProviderId() string {
	if m != nil && m.ProviderId != nil {
		return *m.ProviderId
	}
	return ""
}

func (m *EntityDTO_CommodityBought) GetBought() []*CommodityDTO {
	if m != nil {
		return m.Bought
	}
	return nil
}

type EntityDTO_StorageData struct {
	StorageType      *string `protobuf:"bytes,1,opt,name=storageType" json:"storageType,omitempty"`
	IpAddress        *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	ExportPath       *string `protobuf:"bytes,3,opt,name=exportPath" json:"exportPath,omitempty"`
	StorageId        *string `protobuf:"bytes,4,opt,name=storageId" json:"storageId,omitempty"`
	LunUuid          *string `protobuf:"bytes,5,opt,name=lunUuid" json:"lunUuid,omitempty"`
	LunId            *int32  `protobuf:"varint,6,opt,name=lunId" json:"lunId,omitempty"`
	Wwn              *string `protobuf:"bytes,7,opt,name=wwn" json:"wwn,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_StorageData) Reset()         { *m = EntityDTO_StorageData{} }
func (m *EntityDTO_StorageData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageData) ProtoMessage()    {}

func (m *EntityDTO_StorageData) GetStorageType() string {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return ""
}

func (m *EntityDTO_StorageData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *EntityDTO_StorageData) GetExportPath() string {
	if m != nil && m.ExportPath != nil {
		return *m.ExportPath
	}
	return ""
}

func (m *EntityDTO_StorageData) GetStorageId() string {
	if m != nil && m.StorageId != nil {
		return *m.StorageId
	}
	return ""
}

func (m *EntityDTO_StorageData) GetLunUuid() string {
	if m != nil && m.LunUuid != nil {
		return *m.LunUuid
	}
	return ""
}

func (m *EntityDTO_StorageData) GetLunId() int32 {
	if m != nil && m.LunId != nil {
		return *m.LunId
	}
	return 0
}

func (m *EntityDTO_StorageData) GetWwn() string {
	if m != nil && m.Wwn != nil {
		return *m.Wwn
	}
	return ""
}

type EntityDTO_DiskArrayData struct {
	StorageId        []string                 `protobuf:"bytes,1,rep,name=storageId" json:"storageId,omitempty"`
	IopsCapacity     *int64                   `protobuf:"varint,2,opt,name=iopsCapacity" json:"iopsCapacity,omitempty"`
	DiskCounts       *EntityDTO_DiskCountData `protobuf:"bytes,3,opt,name=diskCounts" json:"diskCounts,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *EntityDTO_DiskArrayData) Reset()         { *m = EntityDTO_DiskArrayData{} }
func (m *EntityDTO_DiskArrayData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_DiskArrayData) ProtoMessage()    {}

func (m *EntityDTO_DiskArrayData) GetStorageId() []string {
	if m != nil {
		return m.StorageId
	}
	return nil
}

func (m *EntityDTO_DiskArrayData) GetIopsCapacity() int64 {
	if m != nil && m.IopsCapacity != nil {
		return *m.IopsCapacity
	}
	return 0
}

func (m *EntityDTO_DiskArrayData) GetDiskCounts() *EntityDTO_DiskCountData {
	if m != nil {
		return m.DiskCounts
	}
	return nil
}

type EntityDTO_ApplicationData struct {
	Type             *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	IpAddress        *string `protobuf:"bytes,2,opt,name=ipAddress" json:"ipAddress,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_ApplicationData) Reset()         { *m = EntityDTO_ApplicationData{} }
func (m *EntityDTO_ApplicationData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ApplicationData) ProtoMessage()    {}

func (m *EntityDTO_ApplicationData) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *EntityDTO_ApplicationData) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

type EntityDTO_VirtualMachineData struct {
	IpAddress []string `protobuf:"bytes,1,rep,name=ipAddress" json:"ipAddress,omitempty"`
	// Carries specific properties for setting Entity State of this VM.
	VmState          *EntityDTO_VMState `protobuf:"bytes,2,opt,name=vmState" json:"vmState,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *EntityDTO_VirtualMachineData) Reset()         { *m = EntityDTO_VirtualMachineData{} }
func (m *EntityDTO_VirtualMachineData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualMachineData) ProtoMessage()    {}

func (m *EntityDTO_VirtualMachineData) GetIpAddress() []string {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EntityDTO_VirtualMachineData) GetVmState() *EntityDTO_VMState {
	if m != nil {
		return m.VmState
	}
	return nil
}

type EntityDTO_VMState struct {
	// Notifies if the VirtualMachine is connected.
	Connected        *bool  `protobuf:"varint,1,opt,name=connected,def=1" json:"connected,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_VMState) Reset()         { *m = EntityDTO_VMState{} }
func (m *EntityDTO_VMState) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VMState) ProtoMessage()    {}

const Default_EntityDTO_VMState_Connected bool = true

func (m *EntityDTO_VMState) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return Default_EntityDTO_VMState_Connected
}

type EntityDTO_PhysicalMachineData struct {
	NumCPUs *int32 `protobuf:"varint,1,opt,name=numCPUs" json:"numCPUs,omitempty"`
	// Carries specific properties for setting Entity State of this PM.
	PmState          *EntityDTO_PMState `protobuf:"bytes,2,opt,name=pmState" json:"pmState,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *EntityDTO_PhysicalMachineData) Reset()         { *m = EntityDTO_PhysicalMachineData{} }
func (m *EntityDTO_PhysicalMachineData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_PhysicalMachineData) ProtoMessage()    {}

func (m *EntityDTO_PhysicalMachineData) GetNumCPUs() int32 {
	if m != nil && m.NumCPUs != nil {
		return *m.NumCPUs
	}
	return 0
}

func (m *EntityDTO_PhysicalMachineData) GetPmState() *EntityDTO_PMState {
	if m != nil {
		return m.PmState
	}
	return nil
}

type EntityDTO_PMState struct {
	// Notifies if the PhysicalMachine is in maintenance.
	Maintenance *bool `protobuf:"varint,1,opt,name=maintenance,def=0" json:"maintenance,omitempty"`
	// Notifies if the PhysicalMachine is for failover.
	Failover         *bool  `protobuf:"varint,2,opt,name=failover,def=0" json:"failover,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_PMState) Reset()         { *m = EntityDTO_PMState{} }
func (m *EntityDTO_PMState) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_PMState) ProtoMessage()    {}

const Default_EntityDTO_PMState_Maintenance bool = false
const Default_EntityDTO_PMState_Failover bool = false

func (m *EntityDTO_PMState) GetMaintenance() bool {
	if m != nil && m.Maintenance != nil {
		return *m.Maintenance
	}
	return Default_EntityDTO_PMState_Maintenance
}

func (m *EntityDTO_PMState) GetFailover() bool {
	if m != nil && m.Failover != nil {
		return *m.Failover
	}
	return Default_EntityDTO_PMState_Failover
}

// Properties specific for a particular type of virtual datacenter
type EntityDTO_VirtualDatacenterTypeProps struct {
	Role             *EntityDTO_VirtualDatacenterRole `protobuf:"varint,1,opt,name=role,enum=common_dto.EntityDTO_VirtualDatacenterRole,def=1" json:"role,omitempty"`
	SupportsNesting  *bool                            `protobuf:"varint,2,opt,name=supportsNesting,def=0" json:"supportsNesting,omitempty"`
	NestedConsumer   *bool                            `protobuf:"varint,3,opt,name=nestedConsumer,def=0" json:"nestedConsumer,omitempty"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *EntityDTO_VirtualDatacenterTypeProps) Reset()         { *m = EntityDTO_VirtualDatacenterTypeProps{} }
func (m *EntityDTO_VirtualDatacenterTypeProps) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualDatacenterTypeProps) ProtoMessage()    {}

const Default_EntityDTO_VirtualDatacenterTypeProps_Role EntityDTO_VirtualDatacenterRole = EntityDTO_CONSUMER
const Default_EntityDTO_VirtualDatacenterTypeProps_SupportsNesting bool = false
const Default_EntityDTO_VirtualDatacenterTypeProps_NestedConsumer bool = false

func (m *EntityDTO_VirtualDatacenterTypeProps) GetRole() EntityDTO_VirtualDatacenterRole {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_Role
}

func (m *EntityDTO_VirtualDatacenterTypeProps) GetSupportsNesting() bool {
	if m != nil && m.SupportsNesting != nil {
		return *m.SupportsNesting
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_SupportsNesting
}

func (m *EntityDTO_VirtualDatacenterTypeProps) GetNestedConsumer() bool {
	if m != nil && m.NestedConsumer != nil {
		return *m.NestedConsumer
	}
	return Default_EntityDTO_VirtualDatacenterTypeProps_NestedConsumer
}

type EntityDTO_VirtualDatacenterData struct {
	PmUuid           []string                              `protobuf:"bytes,1,rep,name=pmUuid" json:"pmUuid,omitempty"`
	VmUuid           []string                              `protobuf:"bytes,2,rep,name=vmUuid" json:"vmUuid,omitempty"`
	SupportsStorage  *bool                                 `protobuf:"varint,3,opt,name=supportsStorage,def=1" json:"supportsStorage,omitempty"`
	VdcTypeProps     *EntityDTO_VirtualDatacenterTypeProps `protobuf:"bytes,4,opt,name=vdc_type_props" json:"vdc_type_props,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *EntityDTO_VirtualDatacenterData) Reset()         { *m = EntityDTO_VirtualDatacenterData{} }
func (m *EntityDTO_VirtualDatacenterData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualDatacenterData) ProtoMessage()    {}

const Default_EntityDTO_VirtualDatacenterData_SupportsStorage bool = true

func (m *EntityDTO_VirtualDatacenterData) GetPmUuid() []string {
	if m != nil {
		return m.PmUuid
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetVmUuid() []string {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *EntityDTO_VirtualDatacenterData) GetSupportsStorage() bool {
	if m != nil && m.SupportsStorage != nil {
		return *m.SupportsStorage
	}
	return Default_EntityDTO_VirtualDatacenterData_SupportsStorage
}

func (m *EntityDTO_VirtualDatacenterData) GetVdcTypeProps() *EntityDTO_VirtualDatacenterTypeProps {
	if m != nil {
		return m.VdcTypeProps
	}
	return nil
}

type EntityDTO_EntityProperty struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EntityDTO_EntityProperty) Reset()         { *m = EntityDTO_EntityProperty{} }
func (m *EntityDTO_EntityProperty) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_EntityProperty) ProtoMessage()    {}

func (m *EntityDTO_EntityProperty) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EntityDTO_EntityProperty) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type EntityDTO_VirtualMachineRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_VirtualMachineRelatedData) Reset()         { *m = EntityDTO_VirtualMachineRelatedData{} }
func (m *EntityDTO_VirtualMachineRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_VirtualMachineRelatedData) ProtoMessage()    {}

func (m *EntityDTO_VirtualMachineRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_VirtualMachineRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

type EntityDTO_PhysicalMachineRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	Io               []*EntityDTO_IoData        `protobuf:"bytes,3,rep,name=io" json:"io,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_PhysicalMachineRelatedData) Reset()         { *m = EntityDTO_PhysicalMachineRelatedData{} }
func (m *EntityDTO_PhysicalMachineRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_PhysicalMachineRelatedData) ProtoMessage()    {}

func (m *EntityDTO_PhysicalMachineRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

func (m *EntityDTO_PhysicalMachineRelatedData) GetIo() []*EntityDTO_IoData {
	if m != nil {
		return m.Io
	}
	return nil
}

type EntityDTO_StorageControllerRelatedData struct {
	Memory           *EntityDTO_MemoryData      `protobuf:"bytes,1,opt,name=memory" json:"memory,omitempty"`
	Processor        []*EntityDTO_ProcessorData `protobuf:"bytes,2,rep,name=processor" json:"processor,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *EntityDTO_StorageControllerRelatedData) Reset() {
	*m = EntityDTO_StorageControllerRelatedData{}
}
func (m *EntityDTO_StorageControllerRelatedData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_StorageControllerRelatedData) ProtoMessage()    {}

func (m *EntityDTO_StorageControllerRelatedData) GetMemory() *EntityDTO_MemoryData {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *EntityDTO_StorageControllerRelatedData) GetProcessor() []*EntityDTO_ProcessorData {
	if m != nil {
		return m.Processor
	}
	return nil
}

type EntityDTO_MemoryData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_MemoryData) Reset()         { *m = EntityDTO_MemoryData{} }
func (m *EntityDTO_MemoryData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_MemoryData) ProtoMessage()    {}

func (m *EntityDTO_MemoryData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_MemoryData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_MemoryData) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

type EntityDTO_ProcessorData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Capacity         *float64 `protobuf:"fixed64,3,opt,name=capacity" json:"capacity,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_ProcessorData) Reset()         { *m = EntityDTO_ProcessorData{} }
func (m *EntityDTO_ProcessorData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ProcessorData) ProtoMessage()    {}

func (m *EntityDTO_ProcessorData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_ProcessorData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_ProcessorData) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

type EntityDTO_IoData struct {
	Id               *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	DisplayName      *string  `protobuf:"bytes,2,opt,name=displayName" json:"displayName,omitempty"`
	Speed            *float64 `protobuf:"fixed64,3,opt,name=speed" json:"speed,omitempty"`
	MacAddress       *string  `protobuf:"bytes,4,opt,name=macAddress" json:"macAddress,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EntityDTO_IoData) Reset()         { *m = EntityDTO_IoData{} }
func (m *EntityDTO_IoData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_IoData) ProtoMessage()    {}

func (m *EntityDTO_IoData) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *EntityDTO_IoData) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *EntityDTO_IoData) GetSpeed() float64 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

func (m *EntityDTO_IoData) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

// Represents the counts of various types of disk drives in a disk array.
// Each count represents the number of discovered disks of that speed.
type EntityDTO_DiskCountData struct {
	// If the hybrid flag is present, it modifies how the included disk counts are
	// used to compute IOPS capacity.
	Hybrid *bool `protobuf:"varint,1,opt,name=hybrid,def=0" json:"hybrid,omitempty"`
	// If the flashAvailable flag is present, it modifies how the included disk counts are
	// used to compute IOPS capacity.
	FlashAvailable   *bool                  `protobuf:"varint,2,opt,name=flashAvailable,def=0" json:"flashAvailable,omitempty"`
	Disks            []*EntityDTO_DiskCount `protobuf:"bytes,3,rep,name=disks" json:"disks,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *EntityDTO_DiskCountData) Reset()         { *m = EntityDTO_DiskCountData{} }
func (m *EntityDTO_DiskCountData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_DiskCountData) ProtoMessage()    {}

const Default_EntityDTO_DiskCountData_Hybrid bool = false
const Default_EntityDTO_DiskCountData_FlashAvailable bool = false

func (m *EntityDTO_DiskCountData) GetHybrid() bool {
	if m != nil && m.Hybrid != nil {
		return *m.Hybrid
	}
	return Default_EntityDTO_DiskCountData_Hybrid
}

func (m *EntityDTO_DiskCountData) GetFlashAvailable() bool {
	if m != nil && m.FlashAvailable != nil {
		return *m.FlashAvailable
	}
	return Default_EntityDTO_DiskCountData_FlashAvailable
}

func (m *EntityDTO_DiskCountData) GetDisks() []*EntityDTO_DiskCount {
	if m != nil {
		return m.Disks
	}
	return nil
}

type EntityDTO_DiskCount struct {
	// Usually derived from the NumDiskNames enum
	NumDiskName *string `protobuf:"bytes,1,req,name=numDiskName" json:"numDiskName,omitempty"`
	// The number of discovered disks of this type.
	NumDisks         *int64 `protobuf:"varint,2,req,name=numDisks" json:"numDisks,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_DiskCount) Reset()         { *m = EntityDTO_DiskCount{} }
func (m *EntityDTO_DiskCount) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_DiskCount) ProtoMessage()    {}

func (m *EntityDTO_DiskCount) GetNumDiskName() string {
	if m != nil && m.NumDiskName != nil {
		return *m.NumDiskName
	}
	return ""
}

func (m *EntityDTO_DiskCount) GetNumDisks() int64 {
	if m != nil && m.NumDisks != nil {
		return *m.NumDisks
	}
	return 0
}

// Meta data representing the entity that will replace this proxy entity
type EntityDTO_ReplacementEntityMetaData struct {
	// Replacement entity is found by matching the values of the specified properties.
	// The value for the property must be set while building the entity. Specific properties
	// are pre-defined for some entity types. Generic properties can be set using
	// the EntityProperty.
	IdentifyingProp []string `protobuf:"bytes,1,rep,name=identifyingProp" json:"identifyingProp,omitempty"`
	// Proxy entities may also transfer their commodity data to the replacement entity
	BuyingCommTypes  []CommodityDTO_CommodityType `protobuf:"varint,2,rep,name=buyingCommTypes,enum=common_dto.CommodityDTO_CommodityType" json:"buyingCommTypes,omitempty"`
	SellingCommTypes []CommodityDTO_CommodityType `protobuf:"varint,3,rep,name=sellingCommTypes,enum=common_dto.CommodityDTO_CommodityType" json:"sellingCommTypes,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *EntityDTO_ReplacementEntityMetaData) Reset()         { *m = EntityDTO_ReplacementEntityMetaData{} }
func (m *EntityDTO_ReplacementEntityMetaData) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ReplacementEntityMetaData) ProtoMessage()    {}

func (m *EntityDTO_ReplacementEntityMetaData) GetIdentifyingProp() []string {
	if m != nil {
		return m.IdentifyingProp
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetBuyingCommTypes() []CommodityDTO_CommodityType {
	if m != nil {
		return m.BuyingCommTypes
	}
	return nil
}

func (m *EntityDTO_ReplacementEntityMetaData) GetSellingCommTypes() []CommodityDTO_CommodityType {
	if m != nil {
		return m.SellingCommTypes
	}
	return nil
}

type EntityDTO_ConsumerPolicy struct {
	ShopsTogether    *bool  `protobuf:"varint,1,opt,name=shopsTogether,def=0" json:"shopsTogether,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EntityDTO_ConsumerPolicy) Reset()         { *m = EntityDTO_ConsumerPolicy{} }
func (m *EntityDTO_ConsumerPolicy) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ConsumerPolicy) ProtoMessage()    {}

const Default_EntityDTO_ConsumerPolicy_ShopsTogether bool = false

func (m *EntityDTO_ConsumerPolicy) GetShopsTogether() bool {
	if m != nil && m.ShopsTogether != nil {
		return *m.ShopsTogether
	}
	return Default_EntityDTO_ConsumerPolicy_ShopsTogether
}

type EntityDTO_ProviderPolicy struct {
	AvailableForPlacement *bool  `protobuf:"varint,1,opt,name=availableForPlacement,def=1" json:"availableForPlacement,omitempty"`
	XXX_unrecognized      []byte `json:"-"`
}

func (m *EntityDTO_ProviderPolicy) Reset()         { *m = EntityDTO_ProviderPolicy{} }
func (m *EntityDTO_ProviderPolicy) String() string { return proto.CompactTextString(m) }
func (*EntityDTO_ProviderPolicy) ProtoMessage()    {}

const Default_EntityDTO_ProviderPolicy_AvailableForPlacement bool = true

func (m *EntityDTO_ProviderPolicy) GetAvailableForPlacement() bool {
	if m != nil && m.AvailableForPlacement != nil {
		return *m.AvailableForPlacement
	}
	return Default_EntityDTO_ProviderPolicy_AvailableForPlacement
}

type CommodityDTO struct {
	// Represents the type of commodity. Check {@link Commodity} enumeration for the available
	// types.
	CommodityType *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	// Represents the key of this commodity.<br>
	// It is a String that represents a specific constraint for this commodity. A commodity bought
	// with a specific key can only buy from a commodity sold that has the same specific key (i.e.
	// those strings should match).
	Key *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// Represents how much of this resource is used.
	// Used is meaningful on both the buying and selling side.
	Used *float64 `protobuf:"fixed64,3,opt,name=used" json:"used,omitempty"`
	// Represents the reservation for this resource.
	// Reservation is only meaningful on the buying side and reserves resources for the buying
	// entity. For example, a VirtualMachine may only be using 1GB of RAM, but but if the VM
	// specifies a reservation of 2GB, it ensures the resources are available if its usage spikes.
	Reservation *float64 `protobuf:"fixed64,4,opt,name=reservation" json:"reservation,omitempty"`
	// Represents the maximum capacity of this resource.
	// Capacity should only be given on the selling side and is used to specify the quantity of a commodity
	// being provided by a given entity.
	Capacity *float64 `protobuf:"fixed64,5,opt,name=capacity" json:"capacity,omitempty"`
	// Represents the limit on this resource.
	// Limit is only meaningful on the selling side and is used to limit the amount of a commodity available
	// for sale on the market to below the value specified in the capacity. For example, a VM may have
	// a VMem capacity of 4GB, but 1GB of that is needed by its operating system. In this example, specify
	// a capacity of 4GB and a limit of 3GB to limit VMem available for sale to applications on the VM.
	Limit *float64 `protobuf:"fixed64,6,opt,name=limit" json:"limit,omitempty"`
	Peak  *float64 `protobuf:"fixed64,7,opt,name=peak" json:"peak,omitempty"`
	// Has meaning on both the buying and selling side.
	// Represents whether the commodity is active and currently participating in the market.
	// Commodities that are inactive will not factor into market recommendations but will still be visible
	// in the Operations Manager UI.
	// Commodities are active by default.
	Active *bool `protobuf:"varint,8,opt,name=active,def=1" json:"active,omitempty"`
	// Has meaning on both the buying and selling side.
	// Represents whether the commodity can be resized. This flag is used to signal to the market
	// whether a commodity is eligible to receive resize up and resize down recommendations.
	// Commodities are not resizable by default.
	Resizable *bool `protobuf:"varint,9,opt,name=resizable,def=0" json:"resizable,omitempty"`
	// The 'displayName' value appears in the product GUI and in reports to identify the commodity.
	DisplayName *string `protobuf:"bytes,10,opt,name=displayName" json:"displayName,omitempty"`
	// Implies if the commodity is thin provisioned.
	// If the commodity is thin provisioned it can be overprovisioned by resizing it.
	// By setting to false. we say overprovision by resizing up is not allowed.
	Thin *bool `protobuf:"varint,11,opt,name=thin,def=1" json:"thin,omitempty"`
	// Property to indicate if the 'used' value for the commodity will be computed by the server
	// or if it is provided by Mediation.
	// The default is 'false' since the Mediation will provide the used value and that will be
	// returned by the server.
	// In situations where Mediation is not able to obtain the used values, it should set
	// this property to 'true'.
	ComputedUsed *bool `protobuf:"varint,12,opt,name=computedUsed,def=0" json:"computedUsed,omitempty"`
	// Property to indicate the amount by which the commodity will be resized.
	UsedIncrement      *float64                         `protobuf:"fixed64,13,opt,name=usedIncrement" json:"usedIncrement,omitempty"`
	StorageLatencyData *CommodityDTO_StorageLatencyData `protobuf:"bytes,500,opt,name=storage_latency_data" json:"storage_latency_data,omitempty"`
	StorageAccessData  *CommodityDTO_StorageAccessData  `protobuf:"bytes,501,opt,name=storage_access_data" json:"storage_access_data,omitempty"`
	XXX_unrecognized   []byte                           `json:"-"`
}

func (m *CommodityDTO) Reset()         { *m = CommodityDTO{} }
func (m *CommodityDTO) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO) ProtoMessage()    {}

const Default_CommodityDTO_Active bool = true
const Default_CommodityDTO_Resizable bool = false
const Default_CommodityDTO_Thin bool = true
const Default_CommodityDTO_ComputedUsed bool = false

func (m *CommodityDTO) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *CommodityDTO) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *CommodityDTO) GetUsed() float64 {
	if m != nil && m.Used != nil {
		return *m.Used
	}
	return 0
}

func (m *CommodityDTO) GetReservation() float64 {
	if m != nil && m.Reservation != nil {
		return *m.Reservation
	}
	return 0
}

func (m *CommodityDTO) GetCapacity() float64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

func (m *CommodityDTO) GetLimit() float64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *CommodityDTO) GetPeak() float64 {
	if m != nil && m.Peak != nil {
		return *m.Peak
	}
	return 0
}

func (m *CommodityDTO) GetActive() bool {
	if m != nil && m.Active != nil {
		return *m.Active
	}
	return Default_CommodityDTO_Active
}

func (m *CommodityDTO) GetResizable() bool {
	if m != nil && m.Resizable != nil {
		return *m.Resizable
	}
	return Default_CommodityDTO_Resizable
}

func (m *CommodityDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *CommodityDTO) GetThin() bool {
	if m != nil && m.Thin != nil {
		return *m.Thin
	}
	return Default_CommodityDTO_Thin
}

func (m *CommodityDTO) GetComputedUsed() bool {
	if m != nil && m.ComputedUsed != nil {
		return *m.ComputedUsed
	}
	return Default_CommodityDTO_ComputedUsed
}

func (m *CommodityDTO) GetUsedIncrement() float64 {
	if m != nil && m.UsedIncrement != nil {
		return *m.UsedIncrement
	}
	return 0
}

func (m *CommodityDTO) GetStorageLatencyData() *CommodityDTO_StorageLatencyData {
	if m != nil {
		return m.StorageLatencyData
	}
	return nil
}

func (m *CommodityDTO) GetStorageAccessData() *CommodityDTO_StorageAccessData {
	if m != nil {
		return m.StorageAccessData
	}
	return nil
}

type CommodityDTO_StorageLatencyData struct {
	SupportsDiskArrayLatency *bool  `protobuf:"varint,1,opt,name=supportsDiskArrayLatency" json:"supportsDiskArrayLatency,omitempty"`
	SupportsStorageLatency   *bool  `protobuf:"varint,2,opt,name=supportsStorageLatency" json:"supportsStorageLatency,omitempty"`
	XXX_unrecognized         []byte `json:"-"`
}

func (m *CommodityDTO_StorageLatencyData) Reset()         { *m = CommodityDTO_StorageLatencyData{} }
func (m *CommodityDTO_StorageLatencyData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageLatencyData) ProtoMessage()    {}

func (m *CommodityDTO_StorageLatencyData) GetSupportsDiskArrayLatency() bool {
	if m != nil && m.SupportsDiskArrayLatency != nil {
		return *m.SupportsDiskArrayLatency
	}
	return false
}

func (m *CommodityDTO_StorageLatencyData) GetSupportsStorageLatency() bool {
	if m != nil && m.SupportsStorageLatency != nil {
		return *m.SupportsStorageLatency
	}
	return false
}

type CommodityDTO_StorageAccessData struct {
	SupportsDiskArrayIOPS *bool  `protobuf:"varint,1,opt,name=supportsDiskArrayIOPS" json:"supportsDiskArrayIOPS,omitempty"`
	SupportsStorageIOPS   *bool  `protobuf:"varint,2,opt,name=supportsStorageIOPS" json:"supportsStorageIOPS,omitempty"`
	XXX_unrecognized      []byte `json:"-"`
}

func (m *CommodityDTO_StorageAccessData) Reset()         { *m = CommodityDTO_StorageAccessData{} }
func (m *CommodityDTO_StorageAccessData) String() string { return proto.CompactTextString(m) }
func (*CommodityDTO_StorageAccessData) ProtoMessage()    {}

func (m *CommodityDTO_StorageAccessData) GetSupportsDiskArrayIOPS() bool {
	if m != nil && m.SupportsDiskArrayIOPS != nil {
		return *m.SupportsDiskArrayIOPS
	}
	return false
}

func (m *CommodityDTO_StorageAccessData) GetSupportsStorageIOPS() bool {
	if m != nil && m.SupportsStorageIOPS != nil {
		return *m.SupportsStorageIOPS
	}
	return false
}

// GroupDTO message carries information to setup Group and Constraint in server.
type GroupDTO struct {
	// Type of entities included in this group
	EntityType *EntityDTO_EntityType `protobuf:"varint,1,req,name=entity_type,enum=common_dto.EntityDTO_EntityType" json:"entity_type,omitempty"`
	// Display name for the group
	DisplayName       *string                     `protobuf:"bytes,2,opt,name=display_name" json:"display_name,omitempty"`
	GroupName         *string                     `protobuf:"bytes,3,opt,name=group_name" json:"group_name,omitempty"`
	ConstraintInfo    *GroupDTO_ConstraintInfo    `protobuf:"bytes,4,opt,name=constraint_info" json:"constraint_info,omitempty"`
	SelectionSpecList *GroupDTO_SelectionSpecList `protobuf:"bytes,5,opt,name=selection_spec_list" json:"selection_spec_list,omitempty"`
	MemberList        *GroupDTO_MembersList       `protobuf:"bytes,6,opt,name=member_list" json:"member_list,omitempty"`
	SourceGroupId     *string                     `protobuf:"bytes,7,opt,name=source_group_id" json:"source_group_id,omitempty"`
	XXX_unrecognized  []byte                      `json:"-"`
}

func (m *GroupDTO) Reset()         { *m = GroupDTO{} }
func (m *GroupDTO) String() string { return proto.CompactTextString(m) }
func (*GroupDTO) ProtoMessage()    {}

func (m *GroupDTO) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *GroupDTO) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *GroupDTO) GetGroupName() string {
	if m != nil && m.GroupName != nil {
		return *m.GroupName
	}
	return ""
}

func (m *GroupDTO) GetConstraintInfo() *GroupDTO_ConstraintInfo {
	if m != nil {
		return m.ConstraintInfo
	}
	return nil
}

func (m *GroupDTO) GetSelectionSpecList() *GroupDTO_SelectionSpecList {
	if m != nil {
		return m.SelectionSpecList
	}
	return nil
}

func (m *GroupDTO) GetMemberList() *GroupDTO_MembersList {
	if m != nil {
		return m.MemberList
	}
	return nil
}

func (m *GroupDTO) GetSourceGroupId() string {
	if m != nil && m.SourceGroupId != nil {
		return *m.SourceGroupId
	}
	return ""
}

// ConstraintInfo contains all necessary information specific for Group associated with Constraint
type GroupDTO_ConstraintInfo struct {
	// Constraint type associated with this group.
	// If it is just a group, then the constraint type should be Group
	ConstraintType *GroupDTO_ConstraintType `protobuf:"varint,1,req,name=constraint_type,enum=common_dto.GroupDTO_ConstraintType" json:"constraint_type,omitempty"`
	// Constraint id to notify
	ConstraintId *string `protobuf:"bytes,2,req,name=constraint_id" json:"constraint_id,omitempty"`
	// Notify if this group is for buyers
	IsBuyer *bool `protobuf:"varint,3,opt,name=is_buyer,def=0" json:"is_buyer,omitempty"`
	// Notify the type of the seller if it is the buyer group.
	BuyerMetaData *GroupDTO_BuyerMetaData `protobuf:"bytes,4,opt,name=buyer_meta_data" json:"buyer_meta_data,omitempty"`
	// Notify if this group is for creating complementary group
	NeedComplementary *bool `protobuf:"varint,5,opt,name=need_complementary,def=0" json:"need_complementary,omitempty"`
	// Name for the constraint
	ConstraintName *string `protobuf:"bytes,6,req,name=constraint_name" json:"constraint_name,omitempty"`
	// Consumers that should not be included in the cluster.
	ForExcludedConsumers *bool  `protobuf:"varint,7,opt,name=forExcludedConsumers,def=0" json:"forExcludedConsumers,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *GroupDTO_ConstraintInfo) Reset()         { *m = GroupDTO_ConstraintInfo{} }
func (m *GroupDTO_ConstraintInfo) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_ConstraintInfo) ProtoMessage()    {}

const Default_GroupDTO_ConstraintInfo_IsBuyer bool = false
const Default_GroupDTO_ConstraintInfo_NeedComplementary bool = false
const Default_GroupDTO_ConstraintInfo_ForExcludedConsumers bool = false

func (m *GroupDTO_ConstraintInfo) GetConstraintType() GroupDTO_ConstraintType {
	if m != nil && m.ConstraintType != nil {
		return *m.ConstraintType
	}
	return GroupDTO_BUYER_SELLER_AFFINITY
}

func (m *GroupDTO_ConstraintInfo) GetConstraintId() string {
	if m != nil && m.ConstraintId != nil {
		return *m.ConstraintId
	}
	return ""
}

func (m *GroupDTO_ConstraintInfo) GetIsBuyer() bool {
	if m != nil && m.IsBuyer != nil {
		return *m.IsBuyer
	}
	return Default_GroupDTO_ConstraintInfo_IsBuyer
}

func (m *GroupDTO_ConstraintInfo) GetBuyerMetaData() *GroupDTO_BuyerMetaData {
	if m != nil {
		return m.BuyerMetaData
	}
	return nil
}

func (m *GroupDTO_ConstraintInfo) GetNeedComplementary() bool {
	if m != nil && m.NeedComplementary != nil {
		return *m.NeedComplementary
	}
	return Default_GroupDTO_ConstraintInfo_NeedComplementary
}

func (m *GroupDTO_ConstraintInfo) GetConstraintName() string {
	if m != nil && m.ConstraintName != nil {
		return *m.ConstraintName
	}
	return ""
}

func (m *GroupDTO_ConstraintInfo) GetForExcludedConsumers() bool {
	if m != nil && m.ForExcludedConsumers != nil {
		return *m.ForExcludedConsumers
	}
	return Default_GroupDTO_ConstraintInfo_ForExcludedConsumers
}

// List of SelectionSpec to select group members
type GroupDTO_SelectionSpecList struct {
	SelectionSpec    []*GroupDTO_SelectionSpec `protobuf:"bytes,1,rep,name=selection_spec" json:"selection_spec,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *GroupDTO_SelectionSpecList) Reset()         { *m = GroupDTO_SelectionSpecList{} }
func (m *GroupDTO_SelectionSpecList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpecList) ProtoMessage()    {}

func (m *GroupDTO_SelectionSpecList) GetSelectionSpec() []*GroupDTO_SelectionSpec {
	if m != nil {
		return m.SelectionSpec
	}
	return nil
}

// List of member uuids
type GroupDTO_MembersList struct {
	Member           []string `protobuf:"bytes,1,rep,name=member" json:"member,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_MembersList) Reset()         { *m = GroupDTO_MembersList{} }
func (m *GroupDTO_MembersList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_MembersList) ProtoMessage()    {}

func (m *GroupDTO_MembersList) GetMember() []string {
	if m != nil {
		return m.Member
	}
	return nil
}

type GroupDTO_BuyerMetaData struct {
	SellerType       *EntityDTO_EntityType `protobuf:"varint,1,opt,name=seller_type,enum=common_dto.EntityDTO_EntityType" json:"seller_type,omitempty"`
	AtMost           *int32                `protobuf:"zigzag32,2,opt,name=at_most,def=-1" json:"at_most,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *GroupDTO_BuyerMetaData) Reset()         { *m = GroupDTO_BuyerMetaData{} }
func (m *GroupDTO_BuyerMetaData) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_BuyerMetaData) ProtoMessage()    {}

const Default_GroupDTO_BuyerMetaData_AtMost int32 = -1

func (m *GroupDTO_BuyerMetaData) GetSellerType() EntityDTO_EntityType {
	if m != nil && m.SellerType != nil {
		return *m.SellerType
	}
	return EntityDTO_SWITCH
}

func (m *GroupDTO_BuyerMetaData) GetAtMost() int32 {
	if m != nil && m.AtMost != nil {
		return *m.AtMost
	}
	return Default_GroupDTO_BuyerMetaData_AtMost
}

// SelectionSpec is used to select group members by checking their property values
type GroupDTO_SelectionSpec struct {
	Property                *string                                    `protobuf:"bytes,1,req,name=property" json:"property,omitempty"`
	ExpressionType          *GroupDTO_SelectionSpec_ExpressionType     `protobuf:"varint,2,req,name=expression_type,enum=common_dto.GroupDTO_SelectionSpec_ExpressionType" json:"expression_type,omitempty"`
	PropertyValueDouble     *float64                                   `protobuf:"fixed64,3,opt,name=property_value_double" json:"property_value_double,omitempty"`
	PropertyValueString     *string                                    `protobuf:"bytes,4,opt,name=property_value_string" json:"property_value_string,omitempty"`
	PropertyValueStringList *GroupDTO_SelectionSpec_PropertyStringList `protobuf:"bytes,5,opt,name=property_value_string_list" json:"property_value_string_list,omitempty"`
	PropertyValueDoubleList *GroupDTO_SelectionSpec_PropertyDoubleList `protobuf:"bytes,6,opt,name=property_value_double_list" json:"property_value_double_list,omitempty"`
	XXX_unrecognized        []byte                                     `json:"-"`
}

func (m *GroupDTO_SelectionSpec) Reset()         { *m = GroupDTO_SelectionSpec{} }
func (m *GroupDTO_SelectionSpec) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec) ProtoMessage()    {}

func (m *GroupDTO_SelectionSpec) GetProperty() string {
	if m != nil && m.Property != nil {
		return *m.Property
	}
	return ""
}

func (m *GroupDTO_SelectionSpec) GetExpressionType() GroupDTO_SelectionSpec_ExpressionType {
	if m != nil && m.ExpressionType != nil {
		return *m.ExpressionType
	}
	return GroupDTO_SelectionSpec_EQUAL_TO
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueDouble() float64 {
	if m != nil && m.PropertyValueDouble != nil {
		return *m.PropertyValueDouble
	}
	return 0
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueString() string {
	if m != nil && m.PropertyValueString != nil {
		return *m.PropertyValueString
	}
	return ""
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueStringList() *GroupDTO_SelectionSpec_PropertyStringList {
	if m != nil {
		return m.PropertyValueStringList
	}
	return nil
}

func (m *GroupDTO_SelectionSpec) GetPropertyValueDoubleList() *GroupDTO_SelectionSpec_PropertyDoubleList {
	if m != nil {
		return m.PropertyValueDoubleList
	}
	return nil
}

// List of string type property value
type GroupDTO_SelectionSpec_PropertyStringList struct {
	PropertyValue    []string `protobuf:"bytes,1,rep,name=property_value" json:"property_value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupDTO_SelectionSpec_PropertyStringList) Reset() {
	*m = GroupDTO_SelectionSpec_PropertyStringList{}
}
func (m *GroupDTO_SelectionSpec_PropertyStringList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec_PropertyStringList) ProtoMessage()    {}

func (m *GroupDTO_SelectionSpec_PropertyStringList) GetPropertyValue() []string {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

// List of double type property value
type GroupDTO_SelectionSpec_PropertyDoubleList struct {
	PropertyValue    []float64 `protobuf:"fixed64,1,rep,name=property_value" json:"property_value,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *GroupDTO_SelectionSpec_PropertyDoubleList) Reset() {
	*m = GroupDTO_SelectionSpec_PropertyDoubleList{}
}
func (m *GroupDTO_SelectionSpec_PropertyDoubleList) String() string { return proto.CompactTextString(m) }
func (*GroupDTO_SelectionSpec_PropertyDoubleList) ProtoMessage()    {}

func (m *GroupDTO_SelectionSpec_PropertyDoubleList) GetPropertyValue() []float64 {
	if m != nil {
		return m.PropertyValue
	}
	return nil
}

func init() {
	proto.RegisterEnum("common_dto.EntityDTO_EntityType", EntityDTO_EntityType_name, EntityDTO_EntityType_value)
	proto.RegisterEnum("common_dto.EntityDTO_PowerState", EntityDTO_PowerState_name, EntityDTO_PowerState_value)
	proto.RegisterEnum("common_dto.EntityDTO_VirtualDatacenterRole", EntityDTO_VirtualDatacenterRole_name, EntityDTO_VirtualDatacenterRole_value)
	proto.RegisterEnum("common_dto.EntityDTO_NumDiskNames", EntityDTO_NumDiskNames_name, EntityDTO_NumDiskNames_value)
	proto.RegisterEnum("common_dto.EntityDTO_EntityOrigin", EntityDTO_EntityOrigin_name, EntityDTO_EntityOrigin_value)
	proto.RegisterEnum("common_dto.CommodityDTO_CommodityType", CommodityDTO_CommodityType_name, CommodityDTO_CommodityType_value)
	proto.RegisterEnum("common_dto.GroupDTO_ConstraintType", GroupDTO_ConstraintType_name, GroupDTO_ConstraintType_value)
	proto.RegisterEnum("common_dto.GroupDTO_SelectionSpec_ExpressionType", GroupDTO_SelectionSpec_ExpressionType_name, GroupDTO_SelectionSpec_ExpressionType_value)
}
