// Code generated by protoc-gen-go.
// source: SupplyChain.proto
// DO NOT EDIT!

package sdk

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type TemplateDTO_TemplateType int32

const (
	TemplateDTO_BASE      TemplateDTO_TemplateType = 0
	TemplateDTO_EXTENSION TemplateDTO_TemplateType = 1
)

var TemplateDTO_TemplateType_name = map[int32]string{
	0: "BASE",
	1: "EXTENSION",
}
var TemplateDTO_TemplateType_value = map[string]int32{
	"BASE":      0,
	"EXTENSION": 1,
}

func (x TemplateDTO_TemplateType) Enum() *TemplateDTO_TemplateType {
	p := new(TemplateDTO_TemplateType)
	*p = x
	return p
}
func (x TemplateDTO_TemplateType) String() string {
	return proto.EnumName(TemplateDTO_TemplateType_name, int32(x))
}
func (x *TemplateDTO_TemplateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TemplateDTO_TemplateType_value, data, "TemplateDTO_TemplateType")
	if err != nil {
		return err
	}
	*x = TemplateDTO_TemplateType(value)
	return nil
}

type Provider_ProviderType int32

const (
	// HOSTING is a To One relationship toward the provider, and it enforces containment.
	// This means that if the provider is removed, then every contained consumer will also be removed.
	Provider_HOSTING Provider_ProviderType = 0
	// LAYERED_OVER is a To Many relationship toward the provider, without containment.
	Provider_LAYERED_OVER Provider_ProviderType = 1
)

var Provider_ProviderType_name = map[int32]string{
	0: "HOSTING",
	1: "LAYERED_OVER",
}
var Provider_ProviderType_value = map[string]int32{
	"HOSTING":      0,
	"LAYERED_OVER": 1,
}

func (x Provider_ProviderType) Enum() *Provider_ProviderType {
	p := new(Provider_ProviderType)
	*p = x
	return p
}
func (x Provider_ProviderType) String() string {
	return proto.EnumName(Provider_ProviderType_name, int32(x))
}
func (x *Provider_ProviderType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Provider_ProviderType_value, data, "Provider_ProviderType")
	if err != nil {
		return err
	}
	*x = Provider_ProviderType(value)
	return nil
}

//
// The TemplateDTO message represents entity types (templates) that the probe expects to
// discover in the target. For the probe to load in Operations Manager, it must discover
// entity types that are valid members of the supply chain, and these entities must have
// valid buy/sell relationships. Specifying the set of templates for a probe serves to
// validate that the specific entities the probe discovers and sends to Operations Manager do
// indeed match the entity descriptions the probe is expected to discover.
//
// Specify entity type by setting an EntityType value to the templateClass field.
//
// An entity can maintain a list of commodities that it sells.
//
// An entity can maintain a map of commodities bought (TemplateCommodity objects). Each map key is
// an instance of Provider. For each provider, the map entry is a list of the commodities bought
// from that provider.
//
// The templateType can be either {@code Base} or
// Extension (see TemplateType).
//
// A Base template indicates the initial representation
// of an entity, which means this probe performs the primary discovery of the entity and places it in the market.
// Note that there can be more than one probe that discovers the same Base entity. The template has a
// templatePriority setting that resolves such a collision. The template with the highest priority value
// wins, and discoveries made for the lower-priority template are ignored.
//
// An extension template adds data to already discovered entities. This is a way to extend the
// commodities managed by a base template.
//
type TemplateDTO struct {
	// The type of entity that the template represents. See EntityType
	// for the available types.
	TemplateClass *EntityDTO_EntityType `protobuf:"varint,1,req,name=templateClass,enum=common_dto.EntityDTO_EntityType" json:"templateClass,omitempty"`
	// The template type (Base or Extension), used during the validation process.
	TemplateType *TemplateDTO_TemplateType `protobuf:"varint,2,req,name=templateType,enum=common_dto.TemplateDTO_TemplateType" json:"templateType,omitempty"`
	// The priority of a Base template. For equivalent Base templates, Operations Manager uses the highest-priority
	// template, and discards discovered data from lower-priority Base templates.
	TemplatePriority *int32 `protobuf:"varint,3,req,name=templatePriority" json:"templatePriority,omitempty"`
	// This entity's list of {@link TemplateCommodity} items that it provides.
	CommoditySold []*TemplateCommodity `protobuf:"bytes,5,rep,name=commoditySold" json:"commoditySold,omitempty"`
	// The commodities bought from the different providers.
	// This Map contains the commodities bought where:
	CommodityBought []*TemplateDTO_CommBoughtProviderProp `protobuf:"bytes,6,rep,name=commodityBought" json:"commodityBought,omitempty"`
	// A map that defines the entity types that will be providers or consumers for this template entity.
	// The entry key is an entity type, from the EntityType enumeration. There can only be
	// one instance of each entity type in this map. The entry value is an instance of
	// ExternalEntityLink. Each entity link describes an entity type in the supply chain,
	// and the commodities it buys from or sells to the template entity.
	ExternalLink     []*TemplateDTO_ExternalEntityLinkProp `protobuf:"bytes,7,rep,name=externalLink" json:"externalLink,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *TemplateDTO) Reset()         { *m = TemplateDTO{} }
func (m *TemplateDTO) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO) ProtoMessage()    {}

func (m *TemplateDTO) GetTemplateClass() EntityDTO_EntityType {
	if m != nil && m.TemplateClass != nil {
		return *m.TemplateClass
	}
	return EntityDTO_SWITCH
}

func (m *TemplateDTO) GetTemplateType() TemplateDTO_TemplateType {
	if m != nil && m.TemplateType != nil {
		return *m.TemplateType
	}
	return TemplateDTO_BASE
}

func (m *TemplateDTO) GetTemplatePriority() int32 {
	if m != nil && m.TemplatePriority != nil {
		return *m.TemplatePriority
	}
	return 0
}

func (m *TemplateDTO) GetCommoditySold() []*TemplateCommodity {
	if m != nil {
		return m.CommoditySold
	}
	return nil
}

func (m *TemplateDTO) GetCommodityBought() []*TemplateDTO_CommBoughtProviderProp {
	if m != nil {
		return m.CommodityBought
	}
	return nil
}

func (m *TemplateDTO) GetExternalLink() []*TemplateDTO_ExternalEntityLinkProp {
	if m != nil {
		return m.ExternalLink
	}
	return nil
}

type TemplateDTO_CommBoughtProviderProp struct {
	// Provider entity type created by the probe
	Key *Provider `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	// The list of commodities bought from the provider specified as key.
	Value            []*TemplateCommodity `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *TemplateDTO_CommBoughtProviderProp) Reset()         { *m = TemplateDTO_CommBoughtProviderProp{} }
func (m *TemplateDTO_CommBoughtProviderProp) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_CommBoughtProviderProp) ProtoMessage()    {}

func (m *TemplateDTO_CommBoughtProviderProp) GetKey() *Provider {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TemplateDTO_CommBoughtProviderProp) GetValue() []*TemplateCommodity {
	if m != nil {
		return m.Value
	}
	return nil
}

type TemplateDTO_ExternalEntityLinkProp struct {
	Key              *EntityDTO_EntityType `protobuf:"varint,1,req,name=key,enum=common_dto.EntityDTO_EntityType" json:"key,omitempty"`
	Value            *ExternalEntityLink   `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *TemplateDTO_ExternalEntityLinkProp) Reset()         { *m = TemplateDTO_ExternalEntityLinkProp{} }
func (m *TemplateDTO_ExternalEntityLinkProp) String() string { return proto.CompactTextString(m) }
func (*TemplateDTO_ExternalEntityLinkProp) ProtoMessage()    {}

func (m *TemplateDTO_ExternalEntityLinkProp) GetKey() EntityDTO_EntityType {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return EntityDTO_SWITCH
}

func (m *TemplateDTO_ExternalEntityLinkProp) GetValue() *ExternalEntityLink {
	if m != nil {
		return m.Value
	}
	return nil
}

type TemplateCommodity struct {
	CommodityType    *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=commodityType,enum=common_dto.CommodityDTO_CommodityType" json:"commodityType,omitempty"`
	Key              *string                     `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *TemplateCommodity) Reset()         { *m = TemplateCommodity{} }
func (m *TemplateCommodity) String() string { return proto.CompactTextString(m) }
func (*TemplateCommodity) ProtoMessage()    {}

func (m *TemplateCommodity) GetCommodityType() CommodityDTO_CommodityType {
	if m != nil && m.CommodityType != nil {
		return *m.CommodityType
	}
	return CommodityDTO_CLUSTER
}

func (m *TemplateCommodity) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

// The Provider class creates a template entity that sells commodities to a
// consumer template.
//
// Each Provider instance has a templateClass to define the entity type, which is expressed
// as a member of the EntityType enumeration.
//
// A provider can have one of two types of relationship with the consumer entity -
// HOSTING or LAYERED_OVER (see ProviderType):
//
// HOSTING is a One Provider/Many Consumers relationship, where the provider contains the consumer.
// This means that if the provider is removed, then every consumer it contains will also be removed.
// For example, a PhysicalMachine contains many VirtualMachines. If you remove the PhysicalMachine
// entity, then its contained VMs will also be removed. You should move VMs off of a host before removing it.
//
// LAYERED_OVER is a Many/Many relationship, with no concept of containment. For example, many VMs
// can share more than one datastore. For LayeredOver relationships, you must specify max and min limits
// to determine how many providers can be layered over the given type of consumer. These values are set in the
// cardinalityMax and cardinalityMin members of this class.
type Provider struct {
	// The type of entity that the provider represents. See {@link Entity}
	// for the available types.
	TemplateClass *EntityDTO_EntityType `protobuf:"varint,1,req,name=templateClass,enum=common_dto.EntityDTO_EntityType" json:"templateClass,omitempty"`
	// ProviderType specifies the type of relationship between the provider and the consumer
	ProviderType *Provider_ProviderType `protobuf:"varint,2,req,name=providerType,enum=common_dto.Provider_ProviderType" json:"providerType,omitempty"`
	// For LAYERED_OVER providers, the maximum number of providers allowed for the consumer.
	CardinalityMax *int32 `protobuf:"varint,3,req,name=cardinalityMax" json:"cardinalityMax,omitempty"`
	// For LAYERED_OVER providers, the minimum number of providers allowed for the consumer.
	CardinalityMin   *int32 `protobuf:"varint,4,req,name=cardinalityMin" json:"cardinalityMin,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Provider) Reset()         { *m = Provider{} }
func (m *Provider) String() string { return proto.CompactTextString(m) }
func (*Provider) ProtoMessage()    {}

func (m *Provider) GetTemplateClass() EntityDTO_EntityType {
	if m != nil && m.TemplateClass != nil {
		return *m.TemplateClass
	}
	return EntityDTO_SWITCH
}

func (m *Provider) GetProviderType() Provider_ProviderType {
	if m != nil && m.ProviderType != nil {
		return *m.ProviderType
	}
	return Provider_HOSTING
}

func (m *Provider) GetCardinalityMax() int32 {
	if m != nil && m.CardinalityMax != nil {
		return *m.CardinalityMax
	}
	return 0
}

func (m *Provider) GetCardinalityMin() int32 {
	if m != nil && m.CardinalityMin != nil {
		return *m.CardinalityMin
	}
	return 0
}

// ExternalEntityLink is a subclass of {@link EntityLink} that
// describes the buy/sell relationship between an entity discovered by the probe, and
// an external entity.
//
// An external entity is one that exists in the
// Operations Manager topology, but has not been discovered by the probe.
// Operations Manager uses this link to stitch discovered entities into the
// existing topology that's managed by the Operations Manager market. This external
// entity can be a provider or a consumer. The ExternalEntityLink object
// contains a full description of the relationship between the external entity and
// the node entity.
// This description includes the entity types for the buyer and seller, the ProviderType
// (the relationship type for the provider, either HOSTING or LAYERED_OVER}),
// and the list of commodities bought from the provider.
//
// To enable stitching, the external link includes a map of {@code probeEntityDef} items
// and a list of ServerEntityPropertyDef items. These work together to identify which
// external entity to stitch together with the probe's discovered entity. The {@code probeEntityDef}
// items store data to identify the appropriate external entity. For example, a discovered application
// can store the IP address of the hosting VM.
//
// The ServerEntityPropertyDef items
// tell Operations Manager how to find identifying information in the external entities.
// For example, the discovered application stores IP address of the hosting VM. Operations Manager
// will use the ServerEntityPropertyDef to test the current VMs for a matching IP address.
type ExternalEntityLink struct {
	// Consumer entity in the link
	BuyerRef *EntityDTO_EntityType `protobuf:"varint,1,req,name=buyerRef,enum=common_dto.EntityDTO_EntityType" json:"buyerRef,omitempty"`
	// Provider entity in the link
	SellerRef *EntityDTO_EntityType `protobuf:"varint,2,req,name=sellerRef,enum=common_dto.EntityDTO_EntityType" json:"sellerRef,omitempty"`
	// Provider relationship type
	Relationship *Provider_ProviderType `protobuf:"varint,3,req,name=relationship,enum=common_dto.Provider_ProviderType" json:"relationship,omitempty"`
	// The list of commodities the consumer entity buys from the provider entity.
	CommodityDefs []*ExternalEntityLink_CommodityDef `protobuf:"bytes,4,rep,name=commodityDefs" json:"commodityDefs,omitempty"`
	// Commodity key
	Key *string `protobuf:"bytes,5,opt,name=key" json:"key,omitempty"`
	// If one of the entity is to be found outside the probe
	HasExternalEntity *bool `protobuf:"varint,6,opt,name=hasExternalEntity" json:"hasExternalEntity,omitempty"`
	// Map of the name and description of the property belonging to the entity instances
	// discovered by the probe.
	ProbeEntityPropertyDef []*ExternalEntityLink_EntityPropertyDef `protobuf:"bytes,7,rep,name=probeEntityPropertyDef" json:"probeEntityPropertyDef,omitempty"`
	// The meta data representing the property definition of the external entity.
	// The value of the property is used for matching the entity instances.
	ExternalEntityPropertyDefs []*ExternalEntityLink_ServerEntityPropDef `protobuf:"bytes,8,rep,name=externalEntityPropertyDefs" json:"externalEntityPropertyDefs,omitempty"`
	XXX_unrecognized           []byte                                    `json:"-"`
}

func (m *ExternalEntityLink) Reset()         { *m = ExternalEntityLink{} }
func (m *ExternalEntityLink) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink) ProtoMessage()    {}

func (m *ExternalEntityLink) GetBuyerRef() EntityDTO_EntityType {
	if m != nil && m.BuyerRef != nil {
		return *m.BuyerRef
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink) GetSellerRef() EntityDTO_EntityType {
	if m != nil && m.SellerRef != nil {
		return *m.SellerRef
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink) GetRelationship() Provider_ProviderType {
	if m != nil && m.Relationship != nil {
		return *m.Relationship
	}
	return Provider_HOSTING
}

func (m *ExternalEntityLink) GetCommodityDefs() []*ExternalEntityLink_CommodityDef {
	if m != nil {
		return m.CommodityDefs
	}
	return nil
}

func (m *ExternalEntityLink) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ExternalEntityLink) GetHasExternalEntity() bool {
	if m != nil && m.HasExternalEntity != nil {
		return *m.HasExternalEntity
	}
	return false
}

func (m *ExternalEntityLink) GetProbeEntityPropertyDef() []*ExternalEntityLink_EntityPropertyDef {
	if m != nil {
		return m.ProbeEntityPropertyDef
	}
	return nil
}

func (m *ExternalEntityLink) GetExternalEntityPropertyDefs() []*ExternalEntityLink_ServerEntityPropDef {
	if m != nil {
		return m.ExternalEntityPropertyDefs
	}
	return nil
}

type ExternalEntityLink_CommodityDef struct {
	Type             *CommodityDTO_CommodityType `protobuf:"varint,1,req,name=type,enum=common_dto.CommodityDTO_CommodityType" json:"type,omitempty"`
	HasKey           *bool                       `protobuf:"varint,2,opt,name=hasKey,def=0" json:"hasKey,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *ExternalEntityLink_CommodityDef) Reset()         { *m = ExternalEntityLink_CommodityDef{} }
func (m *ExternalEntityLink_CommodityDef) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_CommodityDef) ProtoMessage()    {}

const Default_ExternalEntityLink_CommodityDef_HasKey bool = false

func (m *ExternalEntityLink_CommodityDef) GetType() CommodityDTO_CommodityType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return CommodityDTO_CLUSTER
}

func (m *ExternalEntityLink_CommodityDef) GetHasKey() bool {
	if m != nil && m.HasKey != nil {
		return *m.HasKey
	}
	return Default_ExternalEntityLink_CommodityDef_HasKey
}

// The ServerEntityPropDef class provides metadata properties for entities
// in the Operations Manager topology that have not been discovered by this probe.
// Operations Manager uses these property values to stitch external entities to the
// entities discovered by the probe.
// An external entity is one that exists in the Operations Manager topology, but has
// not been discovered by the probe.
//
// The link definition identifies:
// * The entity type for this external entity
// * An attribute of the entity to use to identify it (for example a physical machine's IP address)
// * A flag to set whether to fetch the attribute from an entity that is related in the
//   Operations Manager topology (for example, use the IP address of a VM's host physical machine)
// * Optionally, a handler that can traverse the topology to find the identifying value
//
// This class includes a set of constants for properties that apply to some of the supported
// entity types. Use these constants to create external links with the most common entity
// types in the Operations Manager topology. You can also use this class to create
// custom external entity link definitions.
//
// EXAMPLE: Connecting a DiskArray to Storage. To connect storage objects to disk arrays that the probe discovers,
// the entity link can use either the LUN ID, WWN, or export path properties. This class includes
// the STORAGE_LUNID, STORAGE_WWN, and STORAGE_REMOTE_HOST constants.
// You can use one of these constants as the ExternalEntityLinkDef in the
// ExternalEntityLink that you create for the discovered disk array.
//
// EXAMPLE: Connecting an Application to a VM. To connect an application the probe discovers to a VM,
// you typically use the VM's IP address. You could also use the VM's unique ID. This class includes
// the VM_IP constant for VM IP addresses, and the VM_UUID constant for the VM unique ID.
// You can use one of these constants as the ExternalEntityLinkDef in the
// ExternalEntityLink that you create for the discovered VM.
type ExternalEntityLink_ServerEntityPropDef struct {
	Entity           *EntityDTO_EntityType               `protobuf:"varint,1,req,name=entity,enum=common_dto.EntityDTO_EntityType" json:"entity,omitempty"`
	Attribute        *string                             `protobuf:"bytes,2,req,name=attribute" json:"attribute,omitempty"`
	UseTopoExt       *bool                               `protobuf:"varint,3,opt,name=useTopoExt" json:"useTopoExt,omitempty"`
	PropertyHandler  *ExternalEntityLink_PropertyHandler `protobuf:"bytes,4,opt,name=propertyHandler" json:"propertyHandler,omitempty"`
	XXX_unrecognized []byte                              `json:"-"`
}

func (m *ExternalEntityLink_ServerEntityPropDef) Reset() {
	*m = ExternalEntityLink_ServerEntityPropDef{}
}
func (m *ExternalEntityLink_ServerEntityPropDef) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_ServerEntityPropDef) ProtoMessage()    {}

func (m *ExternalEntityLink_ServerEntityPropDef) GetEntity() EntityDTO_EntityType {
	if m != nil && m.Entity != nil {
		return *m.Entity
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink_ServerEntityPropDef) GetAttribute() string {
	if m != nil && m.Attribute != nil {
		return *m.Attribute
	}
	return ""
}

func (m *ExternalEntityLink_ServerEntityPropDef) GetUseTopoExt() bool {
	if m != nil && m.UseTopoExt != nil {
		return *m.UseTopoExt
	}
	return false
}

func (m *ExternalEntityLink_ServerEntityPropDef) GetPropertyHandler() *ExternalEntityLink_PropertyHandler {
	if m != nil {
		return m.PropertyHandler
	}
	return nil
}

// Holds a property for the probe's discovered entity that Operations Manager can use to stitch the discovered entity
// into the Operations Manager topology. Each property contains a property name and a description.
//
// The property name specifies which property of the discovered entity you want to match. The discovered
// entity's DTO contains the list of properties and values for that entity. This link must include a property that matches a
// named property in the DTO. Note that the SDK includes builders for different types of entities.
// These builders add properties to the entity DTO, giving them names from the {@link SupplyChainConstants} enumeration.
// However, you can use arbitrary names for these properties, so long as the named property is declared in the
// entity DTO.
//
// The properties you create here match the property names in the target DTO.
// For example, the {link ApplicationBuilder} adds an IP address as a property named {@code SupplyChainConstants.IP_ADDRESS}.
// To match the application IP address in this link, add a property to the link with the same name. By doing that,
// the stitching process can access the value that is set in the discovered entity's DTO.
//
// The property description is an arbitrary string to describe the purpose of this property. This is useful
// when you print out the link via a {@code toString()} method.
type ExternalEntityLink_EntityPropertyDef struct {
	// An entity property name
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// An arbitrary description
	Description      *string `protobuf:"bytes,2,req,name=description" json:"description,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExternalEntityLink_EntityPropertyDef) Reset()         { *m = ExternalEntityLink_EntityPropertyDef{} }
func (m *ExternalEntityLink_EntityPropertyDef) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_EntityPropertyDef) ProtoMessage()    {}

func (m *ExternalEntityLink_EntityPropertyDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExternalEntityLink_EntityPropertyDef) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

// The PropertyHandler class manages handler methods that
// Operations Manager can use to traverse the topology to get value(s) of the specified attribute.
// The class assembles a linked list of handlers that can be used to inspect multiple
// layers of the topology to get properties from different entity types.
// Forms LinkedList structure to maintain multiple layers of property names and entity types.
// Example:
// PropertyHandler ipHandler {
//                nextHandler: null
//                methodName: "getAddress"
//                entity: Entity.IP
//                directlyApply: false
//                }</pre></code>
// ipHandler can be used to retrieve IP address string values from IP object.
type ExternalEntityLink_PropertyHandler struct {
	MethodName *string               `protobuf:"bytes,1,req,name=methodName" json:"methodName,omitempty"`
	EntityType *EntityDTO_EntityType `protobuf:"varint,2,opt,name=entityType,enum=common_dto.EntityDTO_EntityType" json:"entityType,omitempty"`
	// it notifies if the method can be directly applied to what returned from the previous layer
	// For example, if it's for IP from VM.getUsesEndPoints(), then directlyApply should be false.
	// Since what returned from VM.getUsesEndPoints() is a list of IPs. So should go to each
	// instance and apply that method.
	DirectlyApply    *bool                               `protobuf:"varint,3,opt,name=directlyApply" json:"directlyApply,omitempty"`
	NextHandler      *ExternalEntityLink_PropertyHandler `protobuf:"bytes,4,opt,name=next_handler" json:"next_handler,omitempty"`
	XXX_unrecognized []byte                              `json:"-"`
}

func (m *ExternalEntityLink_PropertyHandler) Reset()         { *m = ExternalEntityLink_PropertyHandler{} }
func (m *ExternalEntityLink_PropertyHandler) String() string { return proto.CompactTextString(m) }
func (*ExternalEntityLink_PropertyHandler) ProtoMessage()    {}

func (m *ExternalEntityLink_PropertyHandler) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *ExternalEntityLink_PropertyHandler) GetEntityType() EntityDTO_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return EntityDTO_SWITCH
}

func (m *ExternalEntityLink_PropertyHandler) GetDirectlyApply() bool {
	if m != nil && m.DirectlyApply != nil {
		return *m.DirectlyApply
	}
	return false
}

func (m *ExternalEntityLink_PropertyHandler) GetNextHandler() *ExternalEntityLink_PropertyHandler {
	if m != nil {
		return m.NextHandler
	}
	return nil
}

func init() {
	proto.RegisterEnum("common_dto.TemplateDTO_TemplateType", TemplateDTO_TemplateType_name, TemplateDTO_TemplateType_value)
	proto.RegisterEnum("common_dto.Provider_ProviderType", Provider_ProviderType_name, Provider_ProviderType_value)
}
